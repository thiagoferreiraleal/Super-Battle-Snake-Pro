<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="screen-orientation" content="portrait">
    <title>Snake Battle Mobile</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            background: #0f0c29;
        }

        body {
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', system-ui, sans-serif;
            position: fixed;
            top: 0;
            left: 0;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-height: 100dvh;
        }

        canvas#gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .ui-overlay {
            position: absolute;
            top: 10px;
            left: 110px;
            color: white;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
            pointer-events: none;
        }

        .score {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .leaderboard {
            position: absolute;
            top: 50px;
            right: 10px;
            background: rgba(0,0,0,0.6);
            padding: 8px;
            border-radius: 8px;
            color: white;
            min-width: 110px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
            pointer-events: none;
        }

        .leaderboard h3 {
            margin-bottom: 4px;
            font-size: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 2px;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            padding: 1px 0;
        }

        .leaderboard-entry.player {
            color: #00ff88;
            font-weight: bold;
        }

        /* Joystick Virtual - √Årea de toque no lado esquerdo */
        .joystick-zone {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 50%;
            height: 100%;
            z-index: 15;
            touch-action: none;
        }

        .joystick-area {
            position: absolute;
            width: 140px;
            height: 140px;
            z-index: 20;
            pointer-events: none;
            display: none;
        }

        .joystick-area.active {
            display: block;
        }

        .joystick-base {
            width: 140px;
            height: 140px;
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .joystick-stick {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), rgba(255,255,255,0.4));
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            left: 50%;
            top: 50%;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: none;
        }

        /* Bot√µes de Poder Mobile - Layout Diamante */
        .powers-mobile {
            position: absolute;
            bottom: 30px;
            right: 20px;
            width: 180px;
            height: 180px;
            z-index: 20;
        }

        .power-btn {
            width: 68px;
            height: 68px;
            border-radius: 50%;
            background: rgba(0,0,0,0.75);
            border: 3px solid rgba(255,255,255,0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 26px;
            position: absolute;
            transition: all 0.15s;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Posi√ß√µes do diamante */
        .power-btn.fireball {
            /* Topo - Fogo */
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .power-btn.ghost {
            /* Direita - Ghost */
            top: 50%;
            right: 0;
            transform: translateY(-50%);
        }

        .power-btn.shield {
            /* Baixo - Escudo */
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .power-btn.boost {
            /* Esquerda - Boost */
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }

        .power-btn span.label {
            font-size: 8px;
            margin-top: 1px;
            text-transform: uppercase;
        }

        .power-btn.ready {
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0,255,136,0.5);
        }

        .power-btn.cooldown {
            opacity: 0.5;
        }

        .power-btn:active {
            transform: scale(0.85);
        }

        /* Reset transforms on active for positioned buttons */
        .power-btn.fireball:active {
            transform: translateX(-50%) scale(0.85);
        }
        .power-btn.ghost:active {
            transform: translateY(-50%) scale(0.85);
        }
        .power-btn.shield:active {
            transform: translateX(-50%) scale(0.85);
        }
        .power-btn.boost:active {
            transform: translateY(-50%) scale(0.85);
        }

        .power-btn.boost { border-color: #feca57; }
        .power-btn.boost.ready { box-shadow: 0 0 20px rgba(254,202,87,0.6); }
        
        .power-btn.fireball { border-color: #ff6b6b; }
        .power-btn.fireball.ready { box-shadow: 0 0 20px rgba(255,107,107,0.6); }
        
        .power-btn.shield { border-color: #48dbfb; }
        .power-btn.shield.ready { box-shadow: 0 0 20px rgba(72,219,251,0.6); }
        
        .power-btn.ghost { border-color: #ff9ff3; }
        .power-btn.ghost.ready { box-shadow: 0 0 20px rgba(255,159,243,0.6); }

        .power-btn.star { border-color: #ffdd00; }
        .power-btn.star.ready { box-shadow: 0 0 20px rgba(255,221,0,0.7), 0 0 40px rgba(255,221,0,0.3); }

        .active-power-indicator.star {
            background: linear-gradient(45deg, rgba(255,221,0,0.9), rgba(255,180,0,0.9));
        }

        .crowns-display {
            background: linear-gradient(45deg, rgba(255,215,0,0.3), rgba(255,180,0,0.2));
            padding: 10px 25px;
            border-radius: 25px;
            border: 2px solid #ffd700;
            font-size: 18px;
            margin-bottom: 15px;
            color: #ffd700;
            font-weight: bold;
        }

        .double-fire-indicator {
            position: absolute;
            top: 120px;
            left: 10px;
            background: rgba(255,100,0,0.8);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            display: none;
            z-index: 10;
        }

        .double-fire-indicator.show {
            display: block;
        }

        /* Menu Button */
        .menu-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 45px;
            height: 45px;
            border-radius: 10px;
            background: rgba(0,0,0,0.6);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 24px;
            cursor: pointer;
            z-index: 25;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-btn:active {
            transform: scale(0.95);
            background: rgba(0,0,0,0.8);
        }

        /* Pause Menu */
        .pause-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .pause-menu.hidden {
            display: none;
        }

        .pause-content {
            text-align: center;
            color: white;
        }

        .pause-content h2 {
            font-size: 32px;
            margin-bottom: 30px;
        }

        .pause-btn {
            display: block;
            width: 250px;
            padding: 18px 30px;
            margin: 15px auto;
            border: none;
            border-radius: 15px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pause-btn.resume {
            background: linear-gradient(45deg, #00cc66, #00ff88);
            color: #000;
        }

        .pause-btn.quit {
            background: linear-gradient(45deg, #cc3333, #ff4444);
            color: white;
        }

        .pause-btn:active {
            transform: scale(0.95);
        }

        /* Difficulty Selector */
        .difficulty-selector {
            margin: 15px 0;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
        }

        .difficulty-label {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 10px;
        }

        .difficulty-options {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .diff-btn {
            padding: 10px 15px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .diff-btn:active {
            transform: scale(0.95);
        }

        .diff-btn.selected {
            border-color: #00ff88;
            background: rgba(0,255,136,0.2);
            box-shadow: 0 0 10px rgba(0,255,136,0.3);
        }

        .diff-btn[data-diff="easy"] { border-color: #4ade80; }
        .diff-btn[data-diff="easy"].selected { background: rgba(74,222,128,0.2); border-color: #4ade80; }
        
        .diff-btn[data-diff="normal"] { border-color: #fbbf24; }
        .diff-btn[data-diff="normal"].selected { background: rgba(251,191,36,0.2); border-color: #fbbf24; }
        
        .diff-btn[data-diff="hard"] { border-color: #f87171; }
        .diff-btn[data-diff="hard"].selected { background: rgba(248,113,113,0.2); border-color: #f87171; }
        
        .diff-btn[data-diff="extreme"] { border-color: #a855f7; }
        .diff-btn[data-diff="extreme"].selected { background: rgba(168,85,247,0.2); border-color: #a855f7; }

        /* Campo de nome */
        .name-input-container {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .name-input-container label {
            font-size: 14px;
            color: #aaa;
        }

        .name-input-container input {
            padding: 12px 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 25px;
            background: rgba(0,0,0,0.5);
            color: white;
            font-size: 16px;
            text-align: center;
            width: 200px;
            outline: none;
            transition: all 0.2s;
        }

        .name-input-container input:focus {
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0,255,136,0.3);
        }

        /* Bot√£o de voltar ao menu */
        .menu-back-btn {
            display: block;
            width: 200px;
            padding: 12px 20px;
            margin: 10px auto 0;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 25px;
            background: rgba(100,100,100,0.5);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .menu-back-btn:active {
            transform: scale(0.95);
            background: rgba(150,150,150,0.5);
        }

        .pause-btn.menu {
            background: linear-gradient(45deg, #666, #888);
            color: white;
        }

        /* Color Selector */
        .color-selector {
            margin: 12px 0;
            padding: 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
        }

        .color-label {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 10px;
        }

        .color-options {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 10px;
        }

        .color-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.3);
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .color-btn:active {
            transform: scale(0.9);
        }

        .color-btn.selected {
            border-color: #fff;
            box-shadow: 0 0 15px rgba(255,255,255,0.5), 0 0 25px rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        .color-btn.rainbow {
            animation: rainbow-border 2s linear infinite;
        }

        @keyframes rainbow-border {
            0% { border-color: #ff0000; }
            17% { border-color: #ff7f00; }
            33% { border-color: #ffff00; }
            50% { border-color: #00ff00; }
            67% { border-color: #0000ff; }
            83% { border-color: #8b00ff; }
            100% { border-color: #ff0000; }
        }

        .snake-preview {
            display: flex;
            justify-content: center;
            margin-top: 8px;
        }

        .snake-preview canvas {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            border-radius: 0 0 50% 50% / 0 0 100% 100%;
            transition: height 0.1s linear;
            pointer-events: none;
        }

        /* ==================== TELA PRINCIPAL PROFISSIONAL ==================== */
        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            color: white;
            z-index: 100;
            padding: 15px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .start-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(255, 107, 107, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 80% 20%, rgba(72, 219, 251, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 40% 40%, rgba(255, 159, 243, 0.1) 0%, transparent 30%);
            pointer-events: none;
        }

        /* Part√≠culas animadas de fundo */
        .particles-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: float-particle 15s infinite linear;
        }

        @keyframes float-particle {
            0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-100vh) rotate(720deg); opacity: 0; }
        }

        /* Logo e T√≠tulo */
        .logo-container {
            position: relative;
            margin-bottom: 5px;
            z-index: 1;
        }

        .game-logo {
            font-size: 40px;
            animation: logo-bounce 2s ease-in-out infinite;
        }

        @keyframes logo-bounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .start-screen h1 {
            font-size: 26px;
            margin-bottom: 2px;
            background: linear-gradient(135deg, #00ff88 0%, #00d4ff 25%, #ff6b6b 50%, #feca57 75%, #ff9ff3 100%);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: gradient-shift 3s ease infinite;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            position: relative;
            z-index: 1;
        }

        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .start-screen .subtitle {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 12px;
            position: relative;
            z-index: 1;
        }

        /* Coroas Display Melhorado */
        .crowns-display {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 180, 0, 0.1) 100%);
            padding: 10px 25px;
            border-radius: 30px;
            border: 2px solid rgba(255, 215, 0, 0.5);
            font-size: 18px;
            margin-bottom: 12px;
            color: #ffd700;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2), inset 0 0 20px rgba(255, 215, 0, 0.1);
            position: relative;
            z-index: 1;
            animation: crown-glow 2s ease-in-out infinite alternate;
        }

        @keyframes crown-glow {
            0% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.2), inset 0 0 20px rgba(255, 215, 0, 0.1); }
            100% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.4), inset 0 0 25px rgba(255, 215, 0, 0.2); }
        }

        /* Container de Personaliza√ß√£o */
        .customization-container {
            display: flex;
            gap: 10px;
            width: 100%;
            max-width: 340px;
            margin-bottom: 12px;
            position: relative;
            z-index: 1;
        }

        /* Campo de Nome Melhorado */
        .name-input-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .name-input-container label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .name-input-container input {
            padding: 12px 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 15px;
            text-align: center;
            outline: none;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .name-input-container input:focus {
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            background: rgba(0, 255, 136, 0.1);
        }

        /* Seletor de Cores Compacto */
        .color-selector {
            flex: 1.2;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .color-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
        }

        .color-options {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .color-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .color-btn:active {
            transform: scale(0.9);
        }

        .color-btn.selected {
            border-color: #fff;
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.6);
            transform: scale(1.15);
        }

        .snake-preview {
            display: flex;
            justify-content: center;
            margin-top: 6px;
        }

        .snake-preview canvas {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Seletor de Dificuldade Melhorado */
        .difficulty-selector {
            width: 100%;
            max-width: 340px;
            margin-bottom: 12px;
            position: relative;
            z-index: 1;
        }

        .difficulty-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
        }

        .difficulty-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        .diff-btn {
            padding: 10px 5px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .diff-btn:active {
            transform: scale(0.95);
        }

        .diff-btn.selected {
            transform: scale(1.02);
        }

        .diff-btn[data-diff="easy"] { border-color: #2ed573; }
        .diff-btn[data-diff="easy"].selected { 
            background: rgba(46, 213, 115, 0.2); 
            box-shadow: 0 0 15px rgba(46, 213, 115, 0.4);
        }

        .diff-btn[data-diff="normal"] { border-color: #feca57; }
        .diff-btn[data-diff="normal"].selected { 
            background: rgba(254, 202, 87, 0.2);
            box-shadow: 0 0 15px rgba(254, 202, 87, 0.4);
        }

        .diff-btn[data-diff="hard"] { border-color: #ff6b6b; }
        .diff-btn[data-diff="hard"].selected { 
            background: rgba(255, 107, 107, 0.2);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.4);
        }

        .diff-btn[data-diff="extreme"] { border-color: #a855f7; }
        .diff-btn[data-diff="extreme"].selected { 
            background: rgba(168, 85, 247, 0.2);
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.4);
        }

        /* Info Cards */
        .info-cards {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            width: 100%;
            max-width: 340px;
            margin-bottom: 12px;
            position: relative;
            z-index: 1;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 10px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .info-card-title {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }

        .info-card-content {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.4;
        }

        /* Power Legend Melhorado */
        .powers-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
            width: 100%;
            max-width: 340px;
            margin-bottom: 12px;
            position: relative;
            z-index: 1;
        }

        .power-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 8px 5px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
        }

        .power-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .power-card .icon {
            font-size: 22px;
            margin-bottom: 3px;
        }

        .power-card .name {
            font-size: 9px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .power-card.boost { border-color: rgba(254, 202, 87, 0.3); }
        .power-card.boost .name { color: #feca57; }

        .power-card.fire { border-color: rgba(255, 107, 107, 0.3); }
        .power-card.fire .name { color: #ff6b6b; }

        .power-card.shield { border-color: rgba(72, 219, 251, 0.3); }
        .power-card.shield .name { color: #48dbfb; }

        .power-card.ghost { border-color: rgba(255, 159, 243, 0.3); }
        .power-card.ghost .name { color: #ff9ff3; }

        /* Rewards Info */
        .rewards-info {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 12px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            position: relative;
            z-index: 1;
        }

        .reward-item {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .reward-item .crown {
            color: #ffd700;
        }

        /* Bot√£o de Personalizar */
        .customize-btn {
            background: linear-gradient(135deg, rgba(255, 159, 243, 0.2) 0%, rgba(168, 85, 247, 0.2) 100%);
            color: white;
            border: 2px solid rgba(255, 159, 243, 0.5);
            padding: 12px 30px;
            font-size: 14px;
            font-weight: 700;
            border-radius: 25px;
            cursor: pointer;
            margin-bottom: 12px;
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
            backdrop-filter: blur(10px);
        }

        .customize-btn:active {
            transform: scale(0.95);
            box-shadow: 0 0 20px rgba(255, 159, 243, 0.5);
        }

        /* ==================== TELA DE PERSONALIZA√á√ÉO ==================== */
        .customize-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            z-index: 150;
            padding: 20px;
            overflow-y: auto;
            transform: translateX(100%);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .customize-screen.active {
            transform: translateX(0);
        }

        .customize-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 30% 20%, rgba(255, 159, 243, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 70% 80%, rgba(0, 255, 136, 0.1) 0%, transparent 40%);
            pointer-events: none;
        }

        .customize-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            max-width: 360px;
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
        }

        .back-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 15px;
            border-radius: 12px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .back-btn:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.2);
        }

        .customize-title {
            font-size: 20px;
            font-weight: 800;
            background: linear-gradient(135deg, #ff9ff3, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Preview Grande da Cobra */
        .snake-preview-large {
            width: 100%;
            max-width: 360px;
            height: 120px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
            overflow: hidden;
        }

        .snake-preview-large canvas {
            width: 100%;
            height: 100%;
        }

        /* Sequ√™ncia de Cores */
        .color-sequence-section {
            width: 100%;
            max-width: 360px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            z-index: 1;
        }

        .section-title {
            font-size: 14px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title .icon {
            font-size: 18px;
        }

        /* Slots de cores da sequ√™ncia */
        .color-slots {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .color-slot {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .color-slot.filled {
            border-style: solid;
            border-color: rgba(255, 255, 255, 0.5);
        }

        .color-slot.selected {
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
            transform: scale(1.1);
        }

        .color-slot .remove-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 18px;
            height: 18px;
            background: #ff4757;
            border-radius: 50%;
            border: none;
            color: white;
            font-size: 12px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .color-slot.filled .remove-btn {
            display: flex;
        }

        /* Paleta de Cores */
        .color-palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .palette-color {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s;
        }

        .palette-color:active {
            transform: scale(0.9);
        }

        .palette-color.selected {
            border-color: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* Presets de Cores */
        .presets-section {
            width: 100%;
            max-width: 360px;
            margin-bottom: 15px;
            position: relative;
            z-index: 1;
        }

        .presets-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .preset-btn {
            padding: 12px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .preset-btn:active {
            transform: scale(0.95);
        }

        .preset-btn.selected {
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }

        .preset-preview {
            display: flex;
            gap: 3px;
        }

        .preset-preview .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .preset-name {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
        }

        /* A√ß√µes */
        .customize-actions {
            display: flex;
            gap: 10px;
            width: 100%;
            max-width: 360px;
            margin-top: auto;
            padding-top: 15px;
            position: relative;
            z-index: 1;
        }

        .clear-btn {
            flex: 1;
            padding: 14px;
            border-radius: 15px;
            border: 2px solid rgba(255, 107, 107, 0.5);
            background: rgba(255, 107, 107, 0.1);
            color: #ff6b6b;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
        }

        .clear-btn:active {
            transform: scale(0.95);
            background: rgba(255, 107, 107, 0.2);
        }

        .save-btn {
            flex: 2;
            padding: 14px;
            border-radius: 15px;
            border: none;
            background: linear-gradient(135deg, #00ff88, #00d4ff);
            color: #000;
            font-size: 14px;
            font-weight: 900;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .save-btn:active {
            transform: scale(0.95);
        }

        /* ==================== TELA DA LOJA ==================== */
        .shop-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            z-index: 150;
            padding: 15px;
            overflow-y: auto;
            transform: translateX(100%);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .shop-screen.active {
            transform: translateX(0);
        }

        .shop-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            max-width: 380px;
            margin-bottom: 15px;
        }

        .shop-title {
            font-size: 22px;
            font-weight: 800;
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .coins-display-shop {
            display: flex;
            align-items: center;
            gap: 5px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 180, 0, 0.1));
            padding: 8px 15px;
            border-radius: 20px;
            border: 2px solid rgba(255, 215, 0, 0.5);
            font-weight: bold;
            color: #ffd700;
        }

        .skins-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            width: 100%;
            max-width: 380px;
            padding-bottom: 20px;
        }

        .skin-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .skin-card.owned {
            border-color: rgba(0, 255, 136, 0.3);
        }

        .skin-card.selected {
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
        }

        .skin-card.locked {
            opacity: 0.8;
        }

        .skin-preview {
            width: 100%;
            height: 50px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .skin-preview canvas {
            width: 100%;
            height: 100%;
        }

        .skin-name {
            font-size: 13px;
            font-weight: 700;
            text-align: center;
        }

        .skin-description {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
        }

        .skin-price {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 14px;
            font-weight: bold;
            color: #ffd700;
        }

        .skin-price.owned {
            color: #00ff88;
        }

        .skin-btn {
            width: 100%;
            padding: 8px;
            border-radius: 10px;
            border: none;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
        }

        .skin-btn.buy {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
        }

        .skin-btn.buy:disabled {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.3);
            cursor: not-allowed;
        }

        .skin-btn.select {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            border: 1px solid rgba(0, 255, 136, 0.5);
        }

        .skin-btn.selected {
            background: #00ff88;
            color: #000;
        }

        .skin-btn:active:not(:disabled) {
            transform: scale(0.95);
        }

        .shop-btn {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 180, 0, 0.1));
            color: #ffd700;
            border: 2px solid rgba(255, 215, 0, 0.5);
            padding: 10px 20px;
            font-size: 13px;
            font-weight: 700;
            border-radius: 20px;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .shop-btn:active {
            transform: scale(0.95);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
        }

        /* Moedas no jogo */
        .coins-hud {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 15px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 16px;
            font-weight: bold;
            color: #ffd700;
            z-index: 15;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .coin-popup {
            position: absolute;
            font-size: 18px;
            font-weight: bold;
            color: #ffd700;
            pointer-events: none;
            animation: coinPopup 1s ease-out forwards;
            z-index: 100;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }

        @keyframes coinPopup {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
        }

        /* Bot√£o de Jogar √âpico */
        .start-btn {
            background: linear-gradient(135deg, #00ff88 0%, #00d4ff 100%);
            color: #000;
            border: none;
            padding: 16px 60px;
            font-size: 20px;
            font-weight: 900;
            border-radius: 30px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            box-shadow: 
                0 5px 30px rgba(0, 255, 136, 0.4),
                0 0 60px rgba(0, 255, 136, 0.2),
                inset 0 -3px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
            overflow: hidden;
        }

        .start-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: btn-shine 2s infinite;
        }

        @keyframes btn-shine {
            0% { left: -100%; }
            50%, 100% { left: 100%; }
        }

        .start-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 15px rgba(0, 255, 136, 0.4);
        }

        /* Game Over Screen */
        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 100;
            padding: 20px;
        }
            font-size: 12px;
        }

        .start-btn {
            padding: 18px 60px;
            font-size: 22px;
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
            -webkit-user-select: none;
            user-select: none;
        }

        .start-btn:active {
            transform: scale(0.95);
        }

        .game-over-screen h2 {
            font-size: 32px;
            color: #ff6b6b;
            margin-bottom: 15px;
        }

        .final-score {
            font-size: 22px;
            margin-bottom: 20px;
        }

        .hidden {
            display: none !important;
        }

        /* Feedback Visual */
        .power-activated {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            pointer-events: none;
            opacity: 0;
            z-index: 30;
            text-shadow: 0 0 20px white;
            animation: none;
        }

        .power-activated.show {
            animation: powerPop 0.5s ease-out forwards;
        }

        @keyframes powerPop {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        /* Minimap Mobile */
        .minimap {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 90px;
            height: 90px;
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            z-index: 10;
            pointer-events: none;
        }

        /* Status dos poderes ativos */
        .active-powers {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
            pointer-events: none;
        }

        .active-power-indicator {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            display: none;
        }

        .active-power-indicator.show {
            display: block;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        .active-power-indicator.shield {
            background: rgba(72,219,251,0.8);
        }

        .active-power-indicator.ghost {
            background: rgba(255,159,243,0.8);
        }

        @keyframes pulse {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div class="ui-overlay">
            <div class="score">üêç <span id="playerSize">10</span></div>
            <div>üíÄ <span id="kills">0</span></div>
        </div>

        <button class="menu-btn" id="menuBtn">‚ò∞</button>

        <div class="pause-menu hidden" id="pauseMenu">
            <div class="pause-content">
                <h2>‚è∏Ô∏è PAUSADO</h2>
                <button class="pause-btn resume" id="resumeBtn">‚ñ∂Ô∏è CONTINUAR</button>
                <button class="pause-btn quit" id="quitBtn">üö™ SAIR DA PARTIDA</button>
                <button class="pause-btn menu" id="mainMenuBtn">üè† MENU PRINCIPAL</button>
            </div>
        </div>

        <div class="leaderboard">
            <h3>üèÜ Top 10</h3>
            <div id="leaderboardContent"></div>
        </div>

        <canvas class="minimap" id="minimap" width="90" height="90"></canvas>

        <div class="active-powers">
            <div class="active-power-indicator shield" id="shieldIndicator">üõ°Ô∏è ESCUDO</div>
            <div class="active-power-indicator ghost" id="ghostIndicator">üëª FANTASMA</div>
            <div class="active-power-indicator star" id="starIndicator">‚≠ê ESTRELA</div>
        </div>

        <div class="double-fire-indicator" id="doubleFireIndicator">üî•x2: <span id="doubleFireCharges">0</span></div>

        <!-- Zona de toque para joystick (lado esquerdo inteiro) -->
        <div class="joystick-zone" id="joystickZone"></div>
        
        <div class="joystick-area" id="joystickArea">
            <div class="joystick-base">
                <div class="joystick-stick" id="joystickStick"></div>
            </div>
        </div>

        <div class="powers-mobile">
            <div class="power-btn boost ready" id="btnBoost" data-power="boost">
                ‚ö°
                <span class="label">Boost</span>
                <div class="cooldown-overlay" style="height: 0%"></div>
            </div>
            <div class="power-btn fireball ready" id="btnFireball" data-power="fireball">
                üî•
                <span class="label">Fogo</span>
                <div class="cooldown-overlay" style="height: 0%"></div>
            </div>
            <div class="power-btn shield ready" id="btnShield" data-power="shield">
                üõ°Ô∏è
                <span class="label">Escudo</span>
                <div class="cooldown-overlay" style="height: 0%"></div>
            </div>
            <div class="power-btn ghost ready" id="btnGhost" data-power="ghost">
                üëª
                <span class="label">Ghost</span>
                <div class="cooldown-overlay" style="height: 0%"></div>
            </div>
        </div>

        <div class="power-activated" id="powerFeedback">‚ö°</div>

        <div class="start-screen" id="startScreen">
            <!-- Part√≠culas de fundo -->
            <div class="particles-bg" id="particlesBg"></div>
            
            <!-- Logo animada -->
            <div class="logo-container">
                <div class="game-logo">üêç</div>
            </div>
            
            <h1 style="margin: 5px 0; font-size: 28px;">Snake Battle</h1>
            <p class="subtitle" style="margin: 0 0 8px 0; font-size: 12px;">Battle Royale Arena</p>
            
            <!-- Moedas e Coroas -->
            <div style="display: flex; gap: 12px; margin-bottom: 8px;">
                <div class="crowns-display" id="startCrowns" style="padding: 6px 12px; font-size: 14px;">
                    üëë <span id="displayCrowns">0</span>
                </div>
                <div class="coins-display-shop" id="startCoins" style="padding: 6px 12px; font-size: 14px;">
                    ü™ô <span id="displayCoins">0</span>
                </div>
            </div>
            
            <!-- Preview da cobra + Nome lado a lado -->
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px; width: 100%; max-width: 320px;">
                <div class="snake-preview" style="margin: 0; flex-shrink: 0;">
                    <canvas id="snakePreviewMini" width="150" height="40"></canvas>
                </div>
                <div class="name-input-container" style="flex: 1; margin: 0;">
                    <input type="text" id="playerNameInput" maxlength="12" placeholder="Seu Nome" value="Jogador" style="padding: 10px; font-size: 14px;">
                </div>
            </div>
            
            <!-- Bot√µes de Personaliza√ß√£o -->
            <div style="display: flex; gap: 8px; margin-bottom: 10px; width: 100%; max-width: 320px;">
                <button class="customize-btn" id="customizeBtn" style="flex: 1; padding: 10px; font-size: 13px;">
                    üé® Cores
                </button>
                <button class="shop-btn" id="shopBtn" style="flex: 1; padding: 10px; font-size: 13px;">
                    üõí Loja
                </button>
            </div>
            
            <!-- Seletor de dificuldade compacto -->
            <div class="difficulty-selector" style="margin-bottom: 8px; padding: 8px;">
                <div class="difficulty-label" style="font-size: 10px; margin-bottom: 5px;">Dificuldade</div>
                <div class="difficulty-options" style="gap: 6px;">
                    <button class="diff-btn" data-diff="easy" style="padding: 6px 10px; font-size: 11px;">üòä<br>F√°cil</button>
                    <button class="diff-btn selected" data-diff="normal" style="padding: 6px 10px; font-size: 11px;">üòê<br>Normal</button>
                    <button class="diff-btn" data-diff="hard" style="padding: 6px 10px; font-size: 11px;">üòà<br>Dif√≠cil</button>
                    <button class="diff-btn" data-diff="extreme" style="padding: 6px 10px; font-size: 11px;">üíÄ<br>Extremo</button>
                </div>
            </div>
            
            <!-- Grid de poderes compacto -->
            <div class="powers-grid" style="gap: 8px; margin-bottom: 8px;">
                <div class="power-card boost" style="padding: 8px;">
                    <div class="icon" style="font-size: 20px;">‚ö°</div>
                    <div class="name" style="font-size: 9px;">Boost</div>
                </div>
                <div class="power-card fire" style="padding: 8px;">
                    <div class="icon" style="font-size: 20px;">üî•</div>
                    <div class="name" style="font-size: 9px;">Fogo</div>
                </div>
                <div class="power-card shield" style="padding: 8px;">
                    <div class="icon" style="font-size: 20px;">üõ°Ô∏è</div>
                    <div class="name" style="font-size: 9px;">Escudo</div>
                </div>
                <div class="power-card ghost" style="padding: 8px;">
                    <div class="icon" style="font-size: 20px;">üëª</div>
                    <div class="name" style="font-size: 9px;">Ghost</div>
                </div>
            </div>
            
            <!-- Recompensas compactas -->
            <div class="rewards-info" style="gap: 15px; margin-bottom: 10px; font-size: 11px;">
                <div class="reward-item">üèÜ 1¬∫ <span class="crown">+10üëë</span></div>
                <div class="reward-item">ü•à 2¬∫ <span class="crown">+6üëë</span></div>
                <div class="reward-item">ü•â 3¬∫ <span class="crown">+4üëë</span></div>
            </div>
            
            <!-- Bot√£o de Jogar -->
            <button class="start-btn" id="startBtn" style="padding: 14px 50px; font-size: 18px;">üéÆ JOGAR</button>
        </div>

        <div class="game-over-screen hidden" id="gameOverScreen">
            <div id="finalPlace" style="font-size: 32px; font-weight: bold; margin-bottom: 15px; text-shadow: 0 0 20px rgba(255,215,0,0.5);">üèÜ 1¬∫ LUGAR</div>
            <div id="crownsEarned" style="font-size: 28px; color: #ffd700; margin-bottom: 20px; text-shadow: 0 0 15px rgba(255,215,0,0.5);">+10 üëë</div>
            <div style="background: rgba(255,255,255,0.08); padding: 20px; border-radius: 15px; margin-bottom: 25px; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(10px);">
                <div style="font-size: 20px; margin-bottom: 12px; color: #ffd700;">üëë Total: <span id="totalCrowns">0</span> coroas</div>
                <div style="font-size: 14px; color: rgba(255,255,255,0.8);">üìè Tamanho M√°ximo: <span id="finalSize">0</span></div>
                <div style="font-size: 14px; color: rgba(255,255,255,0.8);">üíÄ Elimina√ß√µes: <span id="finalKills">0</span></div>
            </div>
            <button class="start-btn" id="restartBtn">üîÑ JOGAR NOVAMENTE</button>
            <button class="menu-back-btn" id="menuBtn2">üè† Menu Principal</button>
        </div>

        <!-- TELA DE PERSONALIZA√á√ÉO -->
        <div class="customize-screen" id="customizeScreen">
            <div class="customize-header">
                <button class="back-btn" id="backFromCustomize">‚Üê Voltar</button>
                <span class="customize-title">üé® Personalizar</span>
                <div style="width: 70px;"></div>
            </div>

            <!-- Preview Grande -->
            <div class="snake-preview-large">
                <canvas id="snakePreviewLarge" width="360" height="120"></canvas>
            </div>

            <!-- Sequ√™ncia de Cores -->
            <div class="color-sequence-section">
                <div class="section-title">
                    <span class="icon">üéØ</span>
                    Sequ√™ncia de Cores (at√© 8)
                </div>
                <div class="color-slots" id="colorSlots">
                    <!-- Slots ser√£o gerados via JS -->
                </div>
                
                <div class="section-title" style="margin-top: 10px;">
                    <span class="icon">üé®</span>
                    Paleta de Cores
                </div>
                <div class="color-palette" id="colorPalette">
                    <!-- Cores ser√£o geradas via JS -->
                </div>
            </div>

            <!-- Presets -->
            <div class="presets-section">
                <div class="section-title">
                    <span class="icon">‚ú®</span>
                    Presets
                </div>
                <div class="presets-grid" id="presetsGrid">
                    <!-- Presets ser√£o gerados via JS -->
                </div>
            </div>

            <!-- A√ß√µes -->
            <div class="customize-actions">
                <button class="clear-btn" id="clearColorsBtn">üóëÔ∏è Limpar</button>
                <button class="save-btn" id="saveColorsBtn">‚úì SALVAR</button>
            </div>
        </div>

        <!-- TELA DA LOJA -->
        <div class="shop-screen" id="shopScreen">
            <div class="shop-header">
                <button class="back-btn" id="backFromShop">‚Üê Voltar</button>
                <span class="shop-title">üõí Loja de Skins</span>
                <div class="coins-display-shop">
                    ü™ô <span id="shopCoins">0</span>
                </div>
            </div>

            <div class="skins-grid" id="skinsGrid">
                <!-- Skins ser√£o geradas via JS -->
            </div>
        </div>

        <!-- HUD de Moedas no Jogo -->
        <div class="coins-hud hidden" id="coinsHud">
            ü™ô <span id="gameCoins">0</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');

        // Ajusta canvas para tela cheia
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const WORLD_WIDTH = 5000;
        const WORLD_HEIGHT = 5000;

        let gameRunning = false;
        let player = null;
        let bots = [];
        let foods = [];
        let projectiles = [];
        let particles = [];
        let powerUps = [];
        let rocks = [];
        let screenShake = { x: 0, y: 0, intensity: 0 };
        let screenFlash = { active: false, color: '#fff', alpha: 0 };
        let camera = { x: 0, y: 0 };
        let kills = 0;
        let totalBots = 25;
        let playerPlace = 0;
        let difficulty = 'normal';
        let playerName = localStorage.getItem('snakeBattleName') || 'Jogador';
        let playerColor = localStorage.getItem('snakeBattleColor') || '#00ff88';
        let playerColorSequence = JSON.parse(localStorage.getItem('snakeBattleColorSequence') || '[]');
        let isRainbowColor = playerColor === 'rainbow';
        let playerCoins = parseInt(localStorage.getItem('snakeBattleCoins') || '5000');
        let unlockedSkins = JSON.parse(localStorage.getItem('snakeBattleUnlockedSkins') || '["default"]');
        let selectedSkin = localStorage.getItem('snakeBattleSelectedSkin') || 'default';

        // Sistema de Skins Especiais
        const SPECIAL_SKINS = {
            default: {
                name: 'Padr√£o',
                price: 0,
                description: 'Skin b√°sica',
                colors: null, // Usa cores personalizadas
                effect: null
            },
            fire: {
                name: 'üî• Fogo Infernal',
                price: 500,
                description: 'Chamas ardentes',
                colors: ['#ff4500', '#ff6600', '#ff8800', '#ffaa00', '#ffcc00'],
                effect: 'fire',
                headType: 'dragon' // Cabe√ßa de drag√£o com chifres
            },
            ice: {
                name: '‚ùÑÔ∏è Gelo √Årtico',
                price: 500,
                description: 'Frio congelante',
                colors: ['#00ffff', '#00ddff', '#00bbff', '#0099ff', '#0077ff'],
                effect: 'ice',
                headType: 'wolf' // Cabe√ßa de lobo gelado
            },
            shark: {
                name: 'ü¶à Tubar√£o',
                price: 600,
                description: 'Predador dos mares',
                colors: ['#4a6fa5', '#6b8fbe', '#8aadd4', '#4a6fa5', '#36536f'],
                effect: 'shark',
                headType: 'shark' // Cabe√ßa de tubar√£o
            },
            galaxy: {
                name: 'üåå Gal√°xia',
                price: 800,
                description: 'Poder c√≥smico',
                colors: ['#9400d3', '#4b0082', '#0000ff', '#00ff00', '#ffff00', '#ff7f00', '#ff0000'],
                effect: 'galaxy',
                headType: 'alien' // Cabe√ßa alien√≠gena
            },
            golden: {
                name: 'üëë Rei Cobra',
                price: 1000,
                description: 'Realeza absoluta',
                colors: ['#ffd700', '#ffec8b', '#ffd700', '#daa520', '#b8860b'],
                effect: 'golden',
                headType: 'king' // Cabe√ßa com coroa
            },
            neon: {
                name: 'ü§ñ Cyber',
                price: 600,
                description: 'Tecnologia do futuro',
                colors: ['#ff00ff', '#00ffff', '#ff00ff', '#00ff00', '#ff00ff'],
                effect: 'neon',
                headType: 'robot' // Cabe√ßa rob√≥tica
            },
            toxic: {
                name: '‚ò†Ô∏è T√≥xico',
                price: 700,
                description: 'Veneno mortal',
                colors: ['#00ff00', '#32cd32', '#00ff00', '#adff2f', '#7fff00'],
                effect: 'toxic',
                headType: 'skull' // Caveira
            },
            dragon: {
                name: 'üêâ Drag√£o',
                price: 1500,
                description: 'Poder lend√°rio!',
                colors: ['#8b0000', '#ff0000', '#ff4500', '#ff6347', '#ff0000'],
                effect: 'dragon',
                headType: 'dragon_epic' // Drag√£o √©pico com chifres grandes
            },
            phoenix: {
                name: 'üî• F√™nix',
                price: 1200,
                description: 'Renas√ßa das cinzas',
                colors: ['#ff4500', '#ff6600', '#ffcc00', '#ff4500', '#ff0000'],
                effect: 'phoenix',
                headType: 'phoenix' // Cabe√ßa de f√™nix com penas
            },
            demon: {
                name: 'üòà Dem√¥nio',
                price: 1800,
                description: 'Terror absoluto',
                colors: ['#660000', '#990000', '#cc0000', '#660000', '#330000'],
                effect: 'demon',
                headType: 'demon' // Cabe√ßa demon√≠aca
            },
            rainbow: {
                name: 'ü¶Ñ Unic√≥rnio',
                price: 2000,
                description: 'M√°gica pura!',
                colors: ['rainbow'],
                effect: 'rainbow',
                headType: 'unicorn' // Unic√≥rnio com chifre
            }
        };

        // Fun√ß√£o para desenhar cabe√ßas especiais
        function drawSpecialHead(ctx, x, y, radius, angle, headType, colors, time) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            
            const primaryColor = colors[0] === 'rainbow' ? `hsl(${(time * 0.1) % 360}, 100%, 50%)` : colors[0];
            const secondaryColor = colors[1] || primaryColor;
            
            switch(headType) {
                case 'dragon':
                case 'dragon_epic':
                    // Cabe√ßa de drag√£o
                    const isEpic = headType === 'dragon_epic';
                    const hornSize = isEpic ? 12 : 8;
                    
                    // Chifres
                    ctx.fillStyle = isEpic ? '#440000' : '#663300';
                    // Chifre esquerdo
                    ctx.beginPath();
                    ctx.moveTo(-3, -radius + 2);
                    ctx.lineTo(-8, -radius - hornSize);
                    ctx.lineTo(0, -radius + 5);
                    ctx.fill();
                    // Chifre direito
                    ctx.beginPath();
                    ctx.moveTo(-3, radius - 2);
                    ctx.lineTo(-8, radius + hornSize);
                    ctx.lineTo(0, radius - 5);
                    ctx.fill();
                    
                    // Olhos de drag√£o (rasgados)
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.ellipse(5, -4, 4, 2.5, 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(5, 4, 4, 2.5, -0.2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Pupilas verticais
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(6, -4, 1.5, 2.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(6, 4, 1.5, 2.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Narinas
                    ctx.fillStyle = '#220000';
                    ctx.beginPath();
                    ctx.arc(radius - 2, -2, 2, 0, Math.PI * 2);
                    ctx.arc(radius - 2, 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (isEpic) {
                        // Escamas na testa
                        ctx.fillStyle = '#880000';
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.arc(-5 - i * 4, 0, 3 - i * 0.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    break;
                    
                case 'shark':
                    // Barbatana dorsal
                    ctx.fillStyle = '#36536f';
                    ctx.beginPath();
                    ctx.moveTo(-5, 0);
                    ctx.lineTo(-2, -radius - 10);
                    ctx.lineTo(5, 0);
                    ctx.fill();
                    
                    // Focinho pontudo
                    ctx.fillStyle = primaryColor;
                    ctx.beginPath();
                    ctx.moveTo(radius, 0);
                    ctx.lineTo(radius + 8, 0);
                    ctx.lineTo(radius, 3);
                    ctx.lineTo(radius, -3);
                    ctx.fill();
                    
                    // Olhos pequenos e amea√ßadores
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(3, -6, 3, 0, Math.PI * 2);
                    ctx.arc(3, 6, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(3.5, -6.5, 1, 0, Math.PI * 2);
                    ctx.arc(3.5, 5.5, 1, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Guelras
                    ctx.strokeStyle = '#2a4a6a';
                    ctx.lineWidth = 1.5;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(-8 - i * 3, -4);
                        ctx.lineTo(-8 - i * 3, 4);
                        ctx.stroke();
                    }
                    break;
                    
                case 'wolf':
                    // Orelhas pontudas
                    ctx.fillStyle = '#88ccff';
                    ctx.beginPath();
                    ctx.moveTo(0, -radius + 2);
                    ctx.lineTo(-6, -radius - 10);
                    ctx.lineTo(4, -radius + 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(0, radius - 2);
                    ctx.lineTo(-6, radius + 10);
                    ctx.lineTo(4, radius - 2);
                    ctx.fill();
                    
                    // Interior das orelhas
                    ctx.fillStyle = '#aaddff';
                    ctx.beginPath();
                    ctx.moveTo(0, -radius + 3);
                    ctx.lineTo(-4, -radius - 6);
                    ctx.lineTo(2, -radius + 3);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(0, radius - 3);
                    ctx.lineTo(-4, radius + 6);
                    ctx.lineTo(2, radius - 3);
                    ctx.fill();
                    
                    // Focinho
                    ctx.fillStyle = '#aaddff';
                    ctx.beginPath();
                    ctx.ellipse(radius - 2, 0, 6, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Nariz
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(radius + 2, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Olhos de lobo
                    ctx.fillStyle = '#00ddff';
                    ctx.beginPath();
                    ctx.arc(4, -5, 4, 0, Math.PI * 2);
                    ctx.arc(4, 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(5, -5, 2, 0, Math.PI * 2);
                    ctx.arc(5, 5, 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'alien':
                    // Cabe√ßa grande alien√≠gena
                    ctx.fillStyle = primaryColor;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, radius + 4, radius + 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Olhos grandes pretos
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(5, -4, 6, 5, 0.3, 0, Math.PI * 2);
                    ctx.ellipse(5, 4, 6, 5, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Brilho nos olhos
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.ellipse(3, -5, 2, 1.5, 0.3, 0, Math.PI * 2);
                    ctx.ellipse(3, 3, 2, 1.5, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'king':
                    // Coroa
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(-8, -radius + 2);
                    ctx.lineTo(-10, -radius - 8);
                    ctx.lineTo(-6, -radius - 3);
                    ctx.lineTo(-2, -radius - 10);
                    ctx.lineTo(2, -radius - 3);
                    ctx.lineTo(6, -radius - 8);
                    ctx.lineTo(8, -radius + 2);
                    ctx.fill();
                    
                    // Joias na coroa
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(-2, -radius - 6, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(-8, -radius - 4, 1.5, 0, Math.PI * 2);
                    ctx.arc(4, -radius - 4, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Olhos reais
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(5, -4, 4, 0, Math.PI * 2);
                    ctx.arc(5, 4, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#8b4513';
                    ctx.beginPath();
                    ctx.arc(6, -4, 2.5, 0, Math.PI * 2);
                    ctx.arc(6, 4, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(6.5, -4, 1.2, 0, Math.PI * 2);
                    ctx.arc(6.5, 4, 1.2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'robot':
                    // Antenas
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-2, -radius + 2);
                    ctx.lineTo(-2, -radius - 8);
                    ctx.moveTo(-2, radius - 2);
                    ctx.lineTo(-2, radius + 8);
                    ctx.stroke();
                    
                    // Bolas das antenas
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(-2, -radius - 10, 3, 0, Math.PI * 2);
                    ctx.arc(-2, radius + 10, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Visor
                    ctx.fillStyle = '#00ffff';
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.roundRect(0, -6, 12, 12, 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Olhos digitais
                    ctx.fillStyle = '#000';
                    ctx.fillRect(3, -4, 3, 3);
                    ctx.fillRect(3, 1, 3, 3);
                    
                    // Brilho do visor
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.fillRect(1, -5, 8, 2);
                    break;
                    
                case 'skull':
                    // Caveira
                    ctx.fillStyle = '#e0e0e0';
                    ctx.beginPath();
                    ctx.arc(0, 0, radius + 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // √ìrbitas dos olhos
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(4, -4, 5, 4, 0, 0, Math.PI * 2);
                    ctx.ellipse(4, 4, 5, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Brilho verde nos olhos
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(4, -4, 2, 0, Math.PI * 2);
                    ctx.arc(4, 4, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Nariz triangular
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.moveTo(radius - 2, 0);
                    ctx.lineTo(radius - 5, -3);
                    ctx.lineTo(radius - 5, 3);
                    ctx.fill();
                    
                    // Dentes
                    ctx.fillStyle = '#fff';
                    ctx.strokeStyle = '#999';
                    ctx.lineWidth = 0.5;
                    for (let i = -2; i <= 2; i++) {
                        ctx.beginPath();
                        ctx.rect(radius - 8, i * 3 - 1, 4, 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                    break;
                    
                case 'phoenix':
                    // Penas de fogo
                    const flameColors = ['#ff0000', '#ff6600', '#ffcc00'];
                    for (let i = 0; i < 5; i++) {
                        const pAngle = (i - 2) * 0.4;
                        const pLength = 8 + Math.sin(time * 0.1 + i) * 3;
                        ctx.fillStyle = flameColors[i % 3];
                        ctx.beginPath();
                        ctx.moveTo(-5, Math.sin(pAngle) * 6);
                        ctx.quadraticCurveTo(-10, Math.sin(pAngle) * 8, -8 - pLength, Math.sin(pAngle) * (10 + i));
                        ctx.quadraticCurveTo(-10, Math.sin(pAngle) * 4, -5, Math.sin(pAngle) * 3);
                        ctx.fill();
                    }
                    
                    // Bico
                    ctx.fillStyle = '#ff8800';
                    ctx.beginPath();
                    ctx.moveTo(radius, 0);
                    ctx.lineTo(radius + 10, 0);
                    ctx.lineTo(radius, 4);
                    ctx.lineTo(radius, -4);
                    ctx.fill();
                    
                    // Olhos flamejantes
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(4, -5, 4, 0, Math.PI * 2);
                    ctx.arc(4, 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(5, -5, 2, 0, Math.PI * 2);
                    ctx.arc(5, 5, 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'demon':
                    // Chifres curvos
                    ctx.fillStyle = '#220000';
                    ctx.beginPath();
                    ctx.moveTo(-2, -radius + 2);
                    ctx.quadraticCurveTo(-15, -radius - 5, -8, -radius - 15);
                    ctx.quadraticCurveTo(-5, -radius - 8, 2, -radius + 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(-2, radius - 2);
                    ctx.quadraticCurveTo(-15, radius + 5, -8, radius + 15);
                    ctx.quadraticCurveTo(-5, radius + 8, 2, radius - 2);
                    ctx.fill();
                    
                    // Olhos demon√≠acos
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(5, -4, 5, 0, Math.PI * 2);
                    ctx.arc(5, 4, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Pupilas
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(6, -4, 2, 4, 0, 0, Math.PI * 2);
                    ctx.ellipse(6, 4, 2, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Marcas faciais
                    ctx.strokeStyle = '#440000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-6, -3);
                    ctx.lineTo(-10, -6);
                    ctx.moveTo(-6, 3);
                    ctx.lineTo(-10, 6);
                    ctx.stroke();
                    break;
                    
                case 'unicorn':
                    // Chifre espiral
                    ctx.save();
                    ctx.translate(radius - 5, 0);
                    ctx.rotate(-Math.PI / 2);
                    
                    const hornGrad = ctx.createLinearGradient(0, 0, 0, 18);
                    hornGrad.addColorStop(0, '#ffd700');
                    hornGrad.addColorStop(0.5, '#ffffff');
                    hornGrad.addColorStop(1, '#ffb6c1');
                    ctx.fillStyle = hornGrad;
                    
                    ctx.beginPath();
                    ctx.moveTo(-4, 0);
                    ctx.lineTo(0, -18);
                    ctx.lineTo(4, 0);
                    ctx.fill();
                    
                    // Espirais no chifre
                    ctx.strokeStyle = '#ddd';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.moveTo(-3 + i * 0.5, -i * 4);
                        ctx.lineTo(3 - i * 0.5, -i * 4);
                        ctx.stroke();
                    }
                    ctx.restore();
                    
                    // Crina colorida
                    const maneColors = ['#ff69b4', '#87ceeb', '#98fb98', '#dda0dd', '#f0e68c'];
                    for (let i = 0; i < 5; i++) {
                        ctx.fillStyle = maneColors[i];
                        ctx.beginPath();
                        ctx.ellipse(-5 - i * 3, -radius - 2 + Math.sin(time * 0.05 + i) * 2, 4, 6, 0.3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Olhos brilhantes
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(4, -5, 5, 0, Math.PI * 2);
                    ctx.arc(4, 5, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // √çris colorida
                    const irisHue = (time * 0.1) % 360;
                    ctx.fillStyle = `hsl(${irisHue}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.arc(5, -5, 3, 0, Math.PI * 2);
                    ctx.arc(5, 5, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Pupila
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(5.5, -5, 1.5, 0, Math.PI * 2);
                    ctx.arc(5.5, 5, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Brilho
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(3, -6, 1.5, 0, Math.PI * 2);
                    ctx.arc(3, 4, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                default:
                    // Olhos normais
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(5, -5, 5, 0, Math.PI * 2);
                    ctx.arc(5, 5, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(6, -5, 2.5, 0, Math.PI * 2);
                    ctx.arc(6, 5, 2.5, 0, Math.PI * 2);
                    ctx.fill();
            }
            
            ctx.restore();
        }

        function saveCoins() {
            localStorage.setItem('snakeBattleCoins', playerCoins.toString());
        }

        function saveUnlockedSkins() {
            localStorage.setItem('snakeBattleUnlockedSkins', JSON.stringify(unlockedSkins));
        }

        function saveSelectedSkin() {
            localStorage.setItem('snakeBattleSelectedSkin', selectedSkin);
        }

        // Paleta de cores dispon√≠veis
        const COLOR_PALETTE = [
            '#00ff88', '#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#00d2d3',
            '#54a0ff', '#5f27cd', '#ff4757', '#2ed573', '#ffffff', '#1e90ff',
            '#ff1493', '#00ffff', '#ffff00', '#ff8c00', '#adff2f', '#ff69b4',
            '#00fa9a', '#7b68ee', '#dc143c', '#00ced1', '#ffd700', '#9400d3'
        ];

        // Presets de cores
        const COLOR_PRESETS = [
            { name: 'Fogo', colors: ['#ff4500', '#ff6b00', '#ffaa00', '#ffdd00'] },
            { name: 'Gelo', colors: ['#00ffff', '#00d4ff', '#00aaff', '#0088ff'] },
            { name: 'Floresta', colors: ['#00ff88', '#00dd66', '#00bb44', '#009922'] },
            { name: 'Sunset', colors: ['#ff6b6b', '#ff9f43', '#feca57', '#ff6b6b'] },
            { name: 'Neon', colors: ['#ff00ff', '#00ffff', '#ffff00', '#ff00ff'] },
            { name: 'Galaxy', colors: ['#9400d3', '#4b0082', '#0000ff', '#00ff00'] },
            { name: 'Candy', colors: ['#ff69b4', '#ffb6c1', '#ff1493', '#ff69b4'] },
            { name: 'Rainbow', colors: ['rainbow'] }
        ];

        // Configura√ß√µes de dificuldade - foco em intelig√™ncia
        const DIFFICULTY_SETTINGS = {
            easy: {
                botSpeed: 3.0,
                botReaction: 0.12,        // Rea√ß√£o muito lenta
                botFireChance: 0.005,     // Atira muito pouco
                botFireAccuracy: 0.2,     // Mira ruim
                botPowerChance: 0.001,
                botAggression: 0.15,      // Muito pouco agressivo
                botPrediction: 0,         // N√£o prev√™ movimento
                botDodgeChance: 0.05,     // Quase n√£o desvia
                botAwareness: 100,        // Raio de percep√ß√£o pequeno
                botTeamUp: false,         // N√£o faz trabalho em equipe
                botFlankChance: 0,        // N√£o flanqueia
                botTrapChance: 0,         // N√£o arma armadilhas
                botPowerUpPriority: 0.1,  // Quase ignora power-ups
                rockCount: 5,
                label: 'üòä F√°cil'
            },
            normal: {
                botSpeed: 3.3,
                botReaction: 0.25,
                botFireChance: 0.015,
                botFireAccuracy: 0.4,
                botPowerChance: 0.003,
                botAggression: 0.35,
                botPrediction: 0.25,
                botDodgeChance: 0.2,
                botAwareness: 180,
                botTeamUp: false,
                botFlankChance: 0.1,
                botTrapChance: 0.05,
                botPowerUpPriority: 0.4,
                rockCount: 8,
                label: 'üòê Normal'
            },
            hard: {
                botSpeed: 3.6,
                botReaction: 0.45,
                botFireChance: 0.03,
                botFireAccuracy: 0.65,
                botPowerChance: 0.006,
                botAggression: 0.55,
                botPrediction: 0.6,
                botDodgeChance: 0.45,
                botAwareness: 250,
                botTeamUp: true,
                botFlankChance: 0.35,
                botTrapChance: 0.15,
                botPowerUpPriority: 0.7,
                rockCount: 10,
                label: 'üòà Dif√≠cil'
            },
            extreme: {
                botSpeed: 3.8,
                botReaction: 0.65,
                botFireChance: 0.05,
                botFireAccuracy: 0.85,
                botPowerChance: 0.01,
                botAggression: 0.75,
                botPrediction: 0.9,
                botDodgeChance: 0.65,
                botAwareness: 350,
                botTeamUp: true,
                botFlankChance: 0.5,
                botTrapChance: 0.25,
                botPowerUpPriority: 0.9,
                rockCount: 12,
                label: 'üíÄ Extremo'
            }
        };

        // Sistema de coroas (persistente)
        let playerCrowns = parseInt(localStorage.getItem('snakeBattleCrowns') || '0');

        function saveCrowns() {
            localStorage.setItem('snakeBattleCrowns', playerCrowns.toString());
        }

        function addCrowns(amount) {
            playerCrowns += amount;
            saveCrowns();
        }

        // Safe Zone
        let safeZone = {
            x: WORLD_WIDTH / 2,
            y: WORLD_HEIGHT / 2,
            currentRadius: 1800,
            targetRadius: 1800,
            minRadius: 250,
            shrinkSpeed: 0.12,
            damageTimer: 0,
            phase: 0,
            nextShrinkTime: 0,
            shrinking: false,
            warningShown: false,
            // Movimento da zona
            moving: false,
            moveTargetX: WORLD_WIDTH / 2,
            moveTargetY: WORLD_HEIGHT / 2,
            moveSpeed: 0.3,
            moveTimer: 0,
            moveInterval: 8000 // Muda de dire√ß√£o a cada 8 segundos
        };
        let gameTime = 0;

        // Joystick state
        let joystickActive = false;
        let joystickAngle = 0;
        let joystickDistance = 0;

        const COLORS = [
            '#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#00d2d3',
            '#54a0ff', '#5f27cd', '#00b894', '#fdcb6e', '#e17055'
        ];

        const POWER_COOLDOWNS = {
            boost: 400,
            fireball: 800,
            shield: 5000,
            ghost: 6000
        };

        // ==================== EFEITOS ESPECIAIS ====================
        
        function createExplosion(x, y, color, count = 15) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                const speed = 3 + Math.random() * 6;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: color,
                    life: 30 + Math.random() * 20,
                    size: 4 + Math.random() * 6,
                    type: 'explosion'
                });
            }
        }

        // Indicador de dano flutuante
        function showDamageIndicator(x, y, damage, color = '#ff4444') {
            particles.push({
                x: x + (Math.random() - 0.5) * 20,
                y: y - 20,
                vx: (Math.random() - 0.5) * 2,
                vy: -3,
                text: (damage > 0 ? '-' : '+') + Math.abs(damage),
                color: color,
                life: 45,
                size: damage >= 5 ? 20 : (damage >= 3 ? 16 : 14),
                type: 'damage'
            });
        }

        function createShockwave(x, y, color) {
            particles.push({
                x, y,
                radius: 10,
                maxRadius: 80,
                color: color,
                life: 20,
                type: 'shockwave'
            });
        }

        function createSparkles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 30,
                    y: y + (Math.random() - 0.5) * 30,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4 - 2,
                    color: color,
                    life: 20 + Math.random() * 15,
                    size: 2 + Math.random() * 4,
                    type: 'sparkle'
                });
            }
        }

        function createTrail(x, y, color, size = 5) {
            particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                color: color,
                life: 15,
                size: size,
                type: 'trail'
            });
        }

        function triggerScreenShake(intensity = 5) {
            screenShake.intensity = intensity;
        }

        function triggerScreenFlash(color = '#fff', alpha = 0.3) {
            screenFlash.active = true;
            screenFlash.color = color;
            screenFlash.alpha = alpha;
        }

        function updateScreenEffects() {
            // Screen shake
            if (screenShake.intensity > 0) {
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity * 2;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity * 2;
                screenShake.intensity *= 0.9;
                if (screenShake.intensity < 0.5) {
                    screenShake.intensity = 0;
                    screenShake.x = 0;
                    screenShake.y = 0;
                }
            }
            
            // Screen flash
            if (screenFlash.active) {
                screenFlash.alpha *= 0.85;
                if (screenFlash.alpha < 0.01) {
                    screenFlash.active = false;
                }
            }
        }

        function drawScreenFlash() {
            if (screenFlash.active) {
                ctx.fillStyle = screenFlash.color;
                ctx.globalAlpha = screenFlash.alpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1;
            }
        }

        class Snake {
            constructor(x, y, color, isPlayer = false) {
                this.segments = [{ x, y }];
                this.color = color;
                this.isPlayer = isPlayer;
                this.isRainbow = (color === 'rainbow');
                this.colorSequence = []; // Sequ√™ncia de cores personalizadas
                this.targetAngle = 0;
                this.angle = 0;
                this.speed = isPlayer ? 4 : 3.5;
                this.baseSpeed = this.speed;
                this.maxSize = 10;
                this.alive = true;
                this.name = isPlayer ? 'Voc√™' : this.generateName();
                
                this.powers = {
                    boost: { ready: true, cooldown: 0, active: false },
                    fireball: { ready: true, cooldown: 0 },
                    shield: { ready: true, cooldown: 0, active: false, duration: 0 },
                    ghost: { ready: true, cooldown: 0, active: false, duration: 0 },
                    star: { ready: true, cooldown: 0, active: false, duration: 0, damageTimer: 0 },
                    doubleFire: { ready: false, cooldown: 0, charges: 0 } // Cargas de tiro duplo
                };

                for (let i = 0; i < this.maxSize - 1; i++) {
                    this.segments.push({ x: x - (i + 1) * 8, y });
                }
            }

            generateName() {
                const names = ['Cobra', 'Serpente', 'Naga', 'Viper', 'Python', 'Mamba'];
                const suffixes = ['Pro', 'Master', 'King', 'Ninja', 'X', '99'];
                return names[Math.floor(Math.random() * names.length)] + suffixes[Math.floor(Math.random() * suffixes.length)];
            }

            update() {
                if (!this.alive) return;

                for (let power in this.powers) {
                    if (this.powers[power].cooldown > 0) {
                        this.powers[power].cooldown -= 16;
                        if (this.powers[power].cooldown <= 0) {
                            this.powers[power].ready = true;
                        }
                    }
                    if (this.powers[power].duration !== undefined && this.powers[power].duration > 0) {
                        this.powers[power].duration -= 16;
                        if (this.powers[power].duration <= 0) {
                            this.powers[power].active = false;
                        }
                    }
                }

                if (this.powers.boost.active && this.maxSize > 5) {
                    if (Math.random() < 0.08) {
                        this.maxSize--;
                        this.dropFood();
                    }
                }

                // Rota√ß√£o mais r√°pida para mobile
                let angleDiff = this.targetAngle - this.angle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                this.angle += angleDiff * 0.4;

                const head = this.segments[0];
                const speed = this.powers.boost.active ? this.speed * 2.5 : this.speed;
                const newHead = {
                    x: head.x + Math.cos(this.angle) * speed,
                    y: head.y + Math.sin(this.angle) * speed
                };

                newHead.x = Math.max(20, Math.min(WORLD_WIDTH - 20, newHead.x));
                newHead.y = Math.max(20, Math.min(WORLD_HEIGHT - 20, newHead.y));

                this.segments.unshift(newHead);

                while (this.segments.length > this.maxSize) {
                    this.segments.pop();
                }
                while (this.segments.length < this.maxSize) {
                    const last = this.segments[this.segments.length - 1];
                    this.segments.push({ ...last });
                }
            }

            dropFood() {
                const tail = this.segments[this.segments.length - 1];
                // Se for rainbow, usa uma cor aleat√≥ria para a comida
                const foodColor = this.isRainbow ? `hsl(${Math.random() * 360}, 100%, 50%)` : this.color;
                foods.push({
                    x: tail.x + (Math.random() - 0.5) * 20,
                    y: tail.y + (Math.random() - 0.5) * 20,
                    value: 1,
                    color: foodColor,
                    radius: 6
                });
            }

            draw() {
                if (!this.alive) return;

                const screenX = x => x - camera.x;
                const screenY = y => y - camera.y;
                const isGhost = this.powers.ghost.active;
                
                for (let i = this.segments.length - 1; i >= 0; i--) {
                    const seg = this.segments[i];
                    const sx = screenX(seg.x);
                    const sy = screenY(seg.y);
                    
                    if (sx < -30 || sx > canvas.width + 30 || sy < -30 || sy > canvas.height + 30) continue;

                    const radius = 14 - (i / this.segments.length) * 5;
                    
                    // Calcula a cor do segmento
                    let segColor = this.color;
                    if (this.isRainbow) {
                        const hue = (Date.now() * 0.1 + i * 15) % 360;
                        segColor = `hsl(${hue}, 100%, 50%)`;
                    } else if (this.colorSequence && this.colorSequence.length > 0) {
                        // Usa sequ√™ncia de cores personalizada
                        const colorIndex = i % this.colorSequence.length;
                        segColor = this.colorSequence[colorIndex];
                        // Protege contra rainbow na sequ√™ncia
                        if (segColor === 'rainbow') {
                            const hue = (Date.now() * 0.1 + i * 15) % 360;
                            segColor = `hsl(${hue}, 100%, 50%)`;
                        }
                    } else if (segColor === 'rainbow') {
                        const hue = (Date.now() * 0.1 + i * 15) % 360;
                        segColor = `hsl(${hue}, 100%, 50%)`;
                    }
                    
                    if (isGhost) {
                        // GHOST: Quase invis√≠vel com borda vis√≠vel
                        ctx.globalAlpha = 0.08;
                        
                        // Preenchimento quase invis√≠vel
                        ctx.beginPath();
                        ctx.arc(sx, sy, radius, 0, Math.PI * 2);
                        ctx.fillStyle = segColor;
                        ctx.fill();
                        
                        // Borda mais vis√≠vel
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.arc(sx, sy, radius, 0, Math.PI * 2);
                        ctx.strokeStyle = segColor;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Efeito de brilho fantasmag√≥rico na borda
                        ctx.globalAlpha = 0.25;
                        ctx.beginPath();
                        ctx.arc(sx, sy, radius + 3, 0, Math.PI * 2);
                        ctx.strokeStyle = '#ff9ff3';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                    } else {
                        // Desenho normal
                        ctx.globalAlpha = 1;
                        
                        // Sombra
                        ctx.beginPath();
                        ctx.arc(sx + 2, sy + 2, radius, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(0,0,0,0.3)';
                        ctx.fill();

                        const gradient = ctx.createRadialGradient(sx - 3, sy - 3, 0, sx, sy, radius);
                        if (this.isRainbow) {
                            const hue = (Date.now() * 0.1 + i * 15) % 360;
                            gradient.addColorStop(0, `hsl(${hue}, 100%, 75%)`);
                            gradient.addColorStop(1, `hsl(${hue}, 100%, 50%)`);
                        } else if (this.colorSequence && this.colorSequence.length > 0) {
                            const safeSegColor = segColor === 'rainbow' ? '#ff00ff' : segColor;
                            gradient.addColorStop(0, this.lightenColor(safeSegColor, 40));
                            gradient.addColorStop(1, safeSegColor);
                        } else {
                            const safeColor = this.color === 'rainbow' ? '#ff00ff' : this.color;
                            gradient.addColorStop(0, this.lightenColor(safeColor, 40));
                            gradient.addColorStop(1, safeColor);
                        }
                        
                        ctx.beginPath();
                        ctx.arc(sx, sy, radius, 0, Math.PI * 2);
                        ctx.fillStyle = gradient;
                        ctx.fill();
                    }

                    // Efeito de escudo melhorado
                    if (this.powers.shield.active && i === 0) {
                        ctx.globalAlpha = 1;
                        const pulseSize = Math.sin(Date.now() * 0.01) * 3;
                        
                        ctx.beginPath();
                        ctx.arc(sx, sy, radius + 18 + pulseSize, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(0, 200, 255, 0.3)';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.arc(sx, sy, radius + 12 + pulseSize, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(0, 220, 255, 0.6)';
                        ctx.lineWidth = 4;
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.arc(sx, sy, radius + 6, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(100, 240, 255, 0.9)';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }

                    // Efeito de fantasma na cabe√ßa
                    if (isGhost && i === 0) {
                        ctx.globalAlpha = 0.6;
                        const ghostPulse = Math.sin(Date.now() * 0.008) * 4;
                        ctx.beginPath();
                        ctx.arc(sx, sy, radius + 10 + ghostPulse, 0, Math.PI * 2);
                        ctx.strokeStyle = '#ff9ff3';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([8, 4]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }

                    // Efeito de estrela - super brilhante dourado
                    if (this.powers.star.active) {
                        const starPulse = Math.sin(Date.now() * 0.015) * 5;
                        const starRotation = Date.now() * 0.005;
                        
                        // Brilho externo dourado
                        ctx.beginPath();
                        ctx.arc(sx, sy, radius + 20 + starPulse, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 220, 0, 0.2)';
                        ctx.fill();
                        
                        // Raios de luz
                        if (i % 3 === 0) {
                            ctx.save();
                            ctx.translate(sx, sy);
                            ctx.rotate(starRotation);
                            for (let r = 0; r < 4; r++) {
                                ctx.rotate(Math.PI / 2);
                                ctx.beginPath();
                                ctx.moveTo(0, -radius - 5);
                                ctx.lineTo(3, -radius - 15 - starPulse);
                                ctx.lineTo(0, -radius - 25 - starPulse);
                                ctx.lineTo(-3, -radius - 15 - starPulse);
                                ctx.closePath();
                                ctx.fillStyle = 'rgba(255, 255, 100, 0.8)';
                                ctx.fill();
                            }
                            ctx.restore();
                        }
                        
                        // Anel brilhante
                        ctx.beginPath();
                        ctx.arc(sx, sy, radius + 8, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgba(255, 255, 0, ${0.6 + Math.sin(Date.now() * 0.02) * 0.3})`;
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                }

                const head = this.segments[0];
                const hx = screenX(head.x);
                const hy = screenY(head.y);

                ctx.globalAlpha = isGhost ? 0.5 : 1;
                
                // Desenha cabe√ßa especial ou olhos normais
                if (this.skinEffect && this.headType) {
                    const skinColors = this.colorSequence.length > 0 ? this.colorSequence : [this.color];
                    drawSpecialHead(ctx, hx, hy, 14, this.angle, this.headType, skinColors, Date.now());
                } else {
                    // Olhos normais
                    const eyeOffset = 6;
                    const eyeAngle1 = this.angle - 0.4;
                    const eyeAngle2 = this.angle + 0.4;
                    
                    ctx.beginPath();
                    ctx.arc(hx + Math.cos(eyeAngle1) * eyeOffset, hy + Math.sin(eyeAngle1) * eyeOffset, 5, 0, Math.PI * 2);
                    ctx.fillStyle = 'white';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(hx + Math.cos(eyeAngle1) * (eyeOffset + 1), hy + Math.sin(eyeAngle1) * (eyeOffset + 1), 2.5, 0, Math.PI * 2);
                    ctx.fillStyle = 'black';
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(hx + Math.cos(eyeAngle2) * eyeOffset, hy + Math.sin(eyeAngle2) * eyeOffset, 5, 0, Math.PI * 2);
                    ctx.fillStyle = 'white';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(hx + Math.cos(eyeAngle2) * (eyeOffset + 1), hy + Math.sin(eyeAngle2) * (eyeOffset + 1), 2.5, 0, Math.PI * 2);
                    ctx.fillStyle = 'black';
                    ctx.fill();
                }

                ctx.globalAlpha = 1;

                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText(this.name, hx, hy - 22);
                ctx.fillText(this.name, hx, hy - 22);

                // Indicador de n√≠vel do tiro (mostra quantidade total: +2, +3, +4...)
                const fireLevel = this.powers.doubleFire.charges;
                if (fireLevel > 0) {
                    const totalShots = 1 + fireLevel; // 1 base + extras
                    const levelText = '+' + totalShots;
                    const indicatorX = hx + 20;
                    const indicatorY = hy - 20;
                    
                    // Brilho pulsante
                    const pulse = Math.sin(Date.now() * 0.008) * 3;
                    
                    // Fundo do indicador com gradiente
                    const grad = ctx.createRadialGradient(indicatorX, indicatorY, 0, indicatorX, indicatorY, 12 + pulse);
                    grad.addColorStop(0, '#ffaa00');
                    grad.addColorStop(0.7, '#ff6600');
                    grad.addColorStop(1, '#ff3300');
                    
                    ctx.beginPath();
                    ctx.arc(indicatorX, indicatorY, 11 + pulse, 0, Math.PI * 2);
                    ctx.fillStyle = grad;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // N√∫mero
                    ctx.font = 'bold 11px Arial';
                    ctx.fillStyle = '#fff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeText(levelText, indicatorX, indicatorY);
                    ctx.fillText(levelText, indicatorX, indicatorY);
                    ctx.textBaseline = 'alphabetic';
                }
            }

            lightenColor(color, percent) {
                // Se for HSL ou rainbow, retorna a cor como est√°
                if (!color || color === 'rainbow' || color.startsWith('hsl')) {
                    return color || '#ffffff';
                }
                try {
                    const num = parseInt(color.replace('#', ''), 16);
                    const amt = Math.round(2.55 * percent);
                    const R = Math.min(255, (num >> 16) + amt);
                    const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
                    const B = Math.min(255, (num & 0x0000FF) + amt);
                    return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
                } catch (e) {
                    return color || '#ffffff';
                }
            }

            usePower(powerName) {
                const power = this.powers[powerName];
                
                // doubleFire e star n√£o precisam de ready check (s√£o colet√°veis)
                if (powerName === 'doubleFire' || powerName === 'star') {
                    // Apenas executa o efeito
                } else {
                    if (!power || !power.ready) return false;
                }
                
                const head = this.segments[0];

                switch (powerName) {
                    case 'boost':
                        power.active = true;
                        power.ready = false;
                        power.cooldown = POWER_COOLDOWNS.boost;
                        setTimeout(() => power.active = false, 350);
                        // Efeito de boost - rastro de energia
                        if (this.isPlayer) {
                            createExplosion(head.x, head.y, '#feca57', 12);
                            triggerScreenShake(3);
                        }
                        break;
                    case 'fireball':
                        // Quantidade de proj√©teis = 1 + cargas de doubleFire
                        const totalProjectiles = 1 + this.powers.doubleFire.charges;
                        const fireAngle = this.angle;
                        const snake = this;
                        
                        // Dispara todos os proj√©teis em sequ√™ncia
                        for (let p = 0; p < totalProjectiles; p++) {
                            const delay = p * 100; // 100ms entre cada tiro
                            
                            if (p === 0) {
                                // Primeiro tiro imediato
                                projectiles.push({
                                    x: head.x + Math.cos(fireAngle) * 25,
                                    y: head.y + Math.sin(fireAngle) * 25,
                                    angle: fireAngle,
                                    speed: 18,
                                    owner: this,
                                    color: '#ff4444',
                                    radius: 10,
                                    damage: 1,
                                    trail: []
                                });
                            } else {
                                // Tiros subsequentes com delay
                                setTimeout(function() {
                                    if (snake.alive) {
                                        const currentHead = snake.segments[0];
                                        projectiles.push({
                                            x: currentHead.x + Math.cos(fireAngle) * 25,
                                            y: currentHead.y + Math.sin(fireAngle) * 25,
                                            angle: fireAngle,
                                            speed: 18,
                                            owner: snake,
                                            color: p % 2 === 0 ? '#ff4444' : '#ff6600',
                                            radius: 10,
                                            damage: 1,
                                            trail: []
                                        });
                                        createExplosion(currentHead.x + Math.cos(fireAngle) * 20, currentHead.y + Math.sin(fireAngle) * 20, '#ff6600', 6);
                                    }
                                }, delay);
                            }
                        }
                        
                        power.ready = false;
                        power.cooldown = POWER_COOLDOWNS.fireball;
                        // Efeito de disparo
                        if (this.isPlayer) {
                            createExplosion(head.x + Math.cos(fireAngle) * 20, head.y + Math.sin(fireAngle) * 20, '#ff6600', 10);
                            triggerScreenShake(4);
                            triggerScreenFlash('#ff4400', 0.15);
                        }
                        break;
                    case 'shield':
                        power.active = true;
                        power.duration = 3000;
                        power.ready = false;
                        power.cooldown = POWER_COOLDOWNS.shield;
                        // Efeito de ativa√ß√£o do escudo
                        if (this.isPlayer) {
                            createShockwave(head.x, head.y, '#00d4ff');
                            createSparkles(head.x, head.y, '#48dbfb', 20);
                            triggerScreenFlash('#00d4ff', 0.2);
                        }
                        break;
                    case 'ghost':
                        power.active = true;
                        power.duration = 2500;
                        power.ready = false;
                        power.cooldown = POWER_COOLDOWNS.ghost;
                        // Efeito fantasma
                        if (this.isPlayer) {
                            createShockwave(head.x, head.y, '#ff9ff3');
                            createSparkles(head.x, head.y, '#ff9ff3', 25);
                            triggerScreenFlash('#ff9ff3', 0.25);
                        }
                        break;
                    case 'star':
                        power.active = true;
                        power.duration = 5000; // 5 segundos de invulnerabilidade
                        // Efeito estrela - super brilhante
                        createShockwave(head.x, head.y, '#ffdd00');
                        createShockwave(head.x, head.y, '#ffffff');
                        createSparkles(head.x, head.y, '#ffff00', 30);
                        createSparkles(head.x, head.y, '#ffffff', 20);
                        if (this.isPlayer) {
                            triggerScreenFlash('#ffff00', 0.4);
                            triggerScreenShake(8);
                        }
                        break;
                    case 'doubleFire':
                        // Adiciona +1 proj√©til extra por coleta (acumula!)
                        this.powers.doubleFire.charges += 1;
                        // Efeito visual
                        createShockwave(head.x, head.y, '#ff6600');
                        createExplosion(head.x, head.y, '#ff4400', 15);
                        if (this.isPlayer) {
                            triggerScreenFlash('#ff6600', 0.3);
                            triggerScreenShake(5);
                        }
                        break;
                }
                return true;
            }

            die() {
                this.alive = false;
                
                // Comida que cai
                for (let i = 0; i < this.segments.length; i++) {
                    const seg = this.segments[i];
                    if (Math.random() < 0.7) {
                        let foodColor = this.color;
                        if (this.isRainbow) {
                            foodColor = `hsl(${(i * 25) % 360}, 100%, 50%)`;
                        } else if (this.colorSequence && this.colorSequence.length > 0) {
                            foodColor = this.colorSequence[i % this.colorSequence.length];
                            if (foodColor === 'rainbow') foodColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                        }
                        if (foodColor === 'rainbow') foodColor = '#ff00ff';
                        
                        foods.push({
                            x: seg.x + (Math.random() - 0.5) * 20,
                            y: seg.y + (Math.random() - 0.5) * 20,
                            value: 1,
                            color: foodColor,
                            radius: 6
                        });
                    }
                }
                
                // Grande explos√£o - usa cor v√°lida
                const head = this.segments[0];
                const explosionColor = this.isRainbow ? `hsl(${Math.random() * 360}, 100%, 50%)` : 
                                       (this.colorSequence && this.colorSequence.length > 0 ? this.colorSequence[0] : this.color);
                const safeColor = explosionColor === 'rainbow' ? '#ff00ff' : explosionColor;
                
                createExplosion(head.x, head.y, safeColor, 25);
                createShockwave(head.x, head.y, safeColor);
                
                // Part√≠culas em cada segmento
                for (let i = 0; i < this.segments.length; i += 2) {
                    const seg = this.segments[i];
                    let segExplosionColor = safeColor;
                    if (this.isRainbow) {
                        segExplosionColor = `hsl(${(i * 30) % 360}, 100%, 50%)`;
                    } else if (this.colorSequence && this.colorSequence.length > 0) {
                        segExplosionColor = this.colorSequence[i % this.colorSequence.length];
                        if (segExplosionColor === 'rainbow') segExplosionColor = '#ff00ff';
                    }
                    createExplosion(seg.x, seg.y, segExplosionColor, 5);
                }
                
                // Se for o player, efeitos extras
                if (this.isPlayer) {
                    triggerScreenShake(15);
                    triggerScreenFlash('#ff0000', 0.5);
                }
            }
        }

        function spawnFood() {
            while (foods.length < 150) {
                // Verifica se n√£o est√° em cima de uma pedra
                let x, y, valid;
                do {
                    x = Math.random() * WORLD_WIDTH;
                    y = Math.random() * WORLD_HEIGHT;
                    valid = true;
                    for (let rock of rocks) {
                        if (Math.hypot(x - rock.x, y - rock.y) < rock.radius + 20) {
                            valid = false;
                            break;
                        }
                    }
                } while (!valid);
                
                foods.push({
                    x, y,
                    value: Math.random() < 0.1 ? 3 : 1,
                    color: COLORS[Math.floor(Math.random() * COLORS.length)],
                    radius: Math.random() < 0.1 ? 10 : 6
                });
            }
        }

        function spawnRocks() {
            const settings = DIFFICULTY_SETTINGS[difficulty];
            rocks = [];
            
            for (let i = 0; i < settings.rockCount; i++) {
                let x, y, valid;
                let attempts = 0;
                
                do {
                    // N√£o spawna no centro (onde o player come√ßa)
                    x = 150 + Math.random() * (WORLD_WIDTH - 300);
                    y = 150 + Math.random() * (WORLD_HEIGHT - 300);
                    valid = true;
                    
                    // N√£o muito perto do centro
                    if (Math.hypot(x - WORLD_WIDTH/2, y - WORLD_HEIGHT/2) < 200) {
                        valid = false;
                    }
                    
                    // N√£o muito perto de outras pedras
                    for (let rock of rocks) {
                        if (Math.hypot(x - rock.x, y - rock.y) < 120) {
                            valid = false;
                            break;
                        }
                    }
                    
                    attempts++;
                } while (!valid && attempts < 50);
                
                if (valid) {
                    const size = 30 + Math.random() * 40;
                    rocks.push({
                        x, y,
                        radius: size,
                        points: generateRockPoints(size),
                        color: `hsl(${30 + Math.random() * 20}, ${20 + Math.random() * 10}%, ${25 + Math.random() * 15}%)`,
                        rotation: Math.random() * Math.PI * 2
                    });
                }
            }
        }

        function generateRockPoints(radius) {
            const points = [];
            const numPoints = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 2;
                const r = radius * (0.7 + Math.random() * 0.4);
                points.push({ 
                    x: Math.cos(angle) * r, 
                    y: Math.sin(angle) * r 
                });
            }
            return points;
        }

        function drawRocks() {
            for (let rock of rocks) {
                const sx = rock.x - camera.x;
                const sy = rock.y - camera.y;
                
                if (sx < -100 || sx > canvas.width + 100 || sy < -100 || sy > canvas.height + 100) continue;
                
                ctx.save();
                ctx.translate(sx, sy);
                ctx.rotate(rock.rotation);
                
                // Sombra
                ctx.beginPath();
                ctx.moveTo(rock.points[0].x + 5, rock.points[0].y + 5);
                for (let i = 1; i < rock.points.length; i++) {
                    ctx.lineTo(rock.points[i].x + 5, rock.points[i].y + 5);
                }
                ctx.closePath();
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fill();
                
                // Pedra principal
                ctx.beginPath();
                ctx.moveTo(rock.points[0].x, rock.points[0].y);
                for (let i = 1; i < rock.points.length; i++) {
                    ctx.lineTo(rock.points[i].x, rock.points[i].y);
                }
                ctx.closePath();
                
                // Gradiente
                const gradient = ctx.createRadialGradient(-rock.radius * 0.3, -rock.radius * 0.3, 0, 0, 0, rock.radius);
                gradient.addColorStop(0, '#5a5a5a');
                gradient.addColorStop(0.5, rock.color);
                gradient.addColorStop(1, '#2a2a2a');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Detalhes/rachaduras
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-rock.radius * 0.2, -rock.radius * 0.3);
                ctx.lineTo(rock.radius * 0.1, rock.radius * 0.2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(rock.radius * 0.3, -rock.radius * 0.2);
                ctx.lineTo(rock.radius * 0.1, rock.radius * 0.3);
                ctx.stroke();
                
                // Brilho
                ctx.beginPath();
                ctx.arc(-rock.radius * 0.25, -rock.radius * 0.25, rock.radius * 0.15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.15)';
                ctx.fill();
                
                ctx.restore();
            }
        }

        function checkRockCollision(x, y, radius = 14) {
            for (let rock of rocks) {
                const dist = Math.hypot(x - rock.x, y - rock.y);
                if (dist < rock.radius + radius) {
                    return rock;
                }
            }
            return null;
        }

        // Moedas no jogo
        let gameCoinsCollected = 0;
        let coins = [];

        function spawnCoins() {
            // M√°ximo de 15 moedas na arena
            if (coins.length < 15 && Math.random() < 0.01) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * (safeZone.currentRadius - 50);
                
                coins.push({
                    x: safeZone.x + Math.cos(angle) * dist,
                    y: safeZone.y + Math.sin(angle) * dist,
                    value: Math.random() < 0.1 ? 10 : (Math.random() < 0.3 ? 5 : 1),
                    radius: 12,
                    rotation: Math.random() * Math.PI * 2
                });
            }
        }

        function drawCoins() {
            for (let coin of coins) {
                const sx = coin.x - camera.x;
                const sy = coin.y - camera.y;
                
                if (sx < -30 || sx > canvas.width + 30 || sy < -30 || sy > canvas.height + 30) continue;
                
                coin.rotation += 0.05;
                const pulse = Math.sin(Date.now() * 0.005) * 2;
                
                // Brilho externo
                ctx.beginPath();
                ctx.arc(sx, sy, coin.radius + 5 + pulse, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                ctx.fill();
                
                // Moeda
                ctx.beginPath();
                ctx.arc(sx, sy, coin.radius, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(sx - 3, sy - 3, 0, sx, sy, coin.radius);
                gradient.addColorStop(0, '#fff7b2');
                gradient.addColorStop(0.5, '#ffd700');
                gradient.addColorStop(1, '#daa520');
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Borda
                ctx.strokeStyle = '#b8860b';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // S√≠mbolo
                ctx.fillStyle = '#b8860b';
                ctx.font = 'bold ' + (coin.value >= 10 ? '10px' : '12px') + ' Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(coin.value >= 10 ? 'üíé' : (coin.value >= 5 ? '‚≠ê' : 'ü™ô'), sx, sy);
            }
        }

        function collectCoins() {
            if (!player || !player.alive) return;
            
            const head = player.segments[0];
            
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                const dist = Math.hypot(head.x - coin.x, head.y - coin.y);
                
                if (dist < 25) {
                    gameCoinsCollected += coin.value;
                    playerCoins += coin.value;
                    saveCoins();
                    
                    // Efeito visual
                    createSparkles(coin.x, coin.y, '#ffd700', 10);
                    showCoinPopup(coin.x, coin.y, coin.value);
                    
                    // Atualiza HUD
                    const gameCoinsEl = document.getElementById('gameCoins');
                    if (gameCoinsEl) gameCoinsEl.textContent = playerCoins;
                    
                    coins.splice(i, 1);
                }
            }
        }

        function showCoinPopup(x, y, value) {
            const popup = document.createElement('div');
            popup.className = 'coin-popup';
            popup.textContent = '+' + value + 'ü™ô';
            popup.style.left = (x - camera.x) + 'px';
            popup.style.top = (y - camera.y) + 'px';
            document.querySelector('.game-container').appendChild(popup);
            
            setTimeout(() => popup.remove(), 1000);
        }

        function spawnPowerUps() {
            // M√°ximo de 3 power-ups na arena por vez
            if (powerUps.length < 3 && Math.random() < 0.003) {
                // Spawn dentro da safe zone
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * (safeZone.currentRadius - 100);
                
                // 50% chance de ser estrela, 50% de ser tiro duplo
                const type = Math.random() < 0.5 ? 'star' : 'doubleFire';
                
                powerUps.push({
                    x: safeZone.x + Math.cos(angle) * dist,
                    y: safeZone.y + Math.sin(angle) * dist,
                    type: type,
                    radius: 20,
                    pulse: 0,
                    rotation: 0
                });
            }
        }

        function drawPowerUps() {
            for (let pu of powerUps) {
                const sx = pu.x - camera.x;
                const sy = pu.y - camera.y;
                
                if (sx < -50 || sx > canvas.width + 50 || sy < -50 || sy > canvas.height + 50) continue;

                pu.pulse += 0.1;
                pu.rotation += 0.03;
                
                const pulseSize = Math.sin(pu.pulse) * 5;
                const glowSize = 30 + pulseSize;
                
                if (pu.type === 'star') {
                    // Brilho externo dourado
                    const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, glowSize);
                    gradient.addColorStop(0, 'rgba(255, 255, 100, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 220, 0, 0.4)');
                    gradient.addColorStop(1, 'rgba(255, 200, 0, 0)');
                    
                    ctx.beginPath();
                    ctx.arc(sx, sy, glowSize, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Estrela
                    ctx.save();
                    ctx.translate(sx, sy);
                    ctx.rotate(pu.rotation);
                    
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * Math.PI * 2 / 5) - Math.PI / 2;
                        const outerRadius = pu.radius + pulseSize;
                        const innerRadius = outerRadius * 0.4;
                        
                        if (i === 0) {
                            ctx.moveTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
                        } else {
                            ctx.lineTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
                        }
                        
                        const innerAngle = angle + Math.PI / 5;
                        ctx.lineTo(Math.cos(innerAngle) * innerRadius, Math.sin(innerAngle) * innerRadius);
                    }
                    ctx.closePath();
                    
                    const starGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, pu.radius);
                    starGrad.addColorStop(0, '#ffffff');
                    starGrad.addColorStop(0.5, '#ffff00');
                    starGrad.addColorStop(1, '#ffaa00');
                    
                    ctx.fillStyle = starGrad;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.restore();
                    
                    if (Math.random() < 0.3) {
                        createSparkles(pu.x, pu.y, '#ffff00', 1);
                    }
                } else if (pu.type === 'doubleFire') {
                    // Brilho externo vermelho/laranja
                    const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, glowSize);
                    gradient.addColorStop(0, 'rgba(255, 100, 50, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 50, 0, 0.4)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    
                    ctx.beginPath();
                    ctx.arc(sx, sy, glowSize, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Duas bolas de fogo (uma atr√°s da outra)
                    ctx.save();
                    ctx.translate(sx, sy);
                    ctx.rotate(pu.rotation * 2);
                    
                    // Primeira bola
                    const fireGrad1 = ctx.createRadialGradient(0, -10, 0, 0, -10, 12);
                    fireGrad1.addColorStop(0, '#ffffff');
                    fireGrad1.addColorStop(0.4, '#ffff00');
                    fireGrad1.addColorStop(0.7, '#ff6600');
                    fireGrad1.addColorStop(1, '#ff0000');
                    
                    ctx.beginPath();
                    ctx.arc(0, -10, 10 + pulseSize * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = fireGrad1;
                    ctx.fill();
                    
                    // Segunda bola
                    const fireGrad2 = ctx.createRadialGradient(0, 10, 0, 0, 10, 10);
                    fireGrad2.addColorStop(0, '#ffffff');
                    fireGrad2.addColorStop(0.4, '#ffff00');
                    fireGrad2.addColorStop(0.7, '#ff6600');
                    fireGrad2.addColorStop(1, '#ff0000');
                    
                    ctx.beginPath();
                    ctx.arc(0, 10, 8 + pulseSize * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = fireGrad2;
                    ctx.fill();
                    
                    // Texto "x2"
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('x2', 0, 0);
                    
                    ctx.restore();
                    
                    if (Math.random() < 0.3) {
                        createSparkles(pu.x, pu.y, '#ff6600', 1);
                    }
                }
            }
        }

        function checkPowerUpCollision() {
            if (!player.alive) return;
            
            const playerHead = player.segments[0];
            
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const pu = powerUps[i];
                const dist = Math.hypot(pu.x - playerHead.x, pu.y - playerHead.y);
                
                if (dist < 30) {
                    // Coletou!
                    player.usePower(pu.type);
                    // Remove o power-up
                    powerUps.splice(i, 1);
                }
            }
            
            // Bots tamb√©m podem coletar
            for (let bot of bots) {
                if (!bot.alive) continue;
                const botHead = bot.segments[0];
                
                for (let i = powerUps.length - 1; i >= 0; i--) {
                    const pu = powerUps[i];
                    const dist = Math.hypot(pu.x - botHead.x, pu.y - botHead.y);
                    
                    if (dist < 30) {
                        bot.usePower(pu.type);
                        powerUps.splice(i, 1);
                    }
                }
            }
        }

        function spawnBots() {
            const settings = DIFFICULTY_SETTINGS[difficulty];
            
            // S√≥ spawna no in√≠cio do jogo, n√£o respawna
            if (bots.length === 0) {
                for (let i = 0; i < totalBots; i++) {
                    // N√£o spawna em cima de pedras
                    let x, y, valid;
                    do {
                        x = 100 + Math.random() * (WORLD_WIDTH - 200);
                        y = 100 + Math.random() * (WORLD_HEIGHT - 200);
                        valid = !checkRockCollision(x, y, 30);
                    } while (!valid);
                    
                    const bot = new Snake(x, y, COLORS[Math.floor(Math.random() * COLORS.length)]);
                    bot.maxSize = 10 + Math.floor(Math.random() * 15);
                    bot.behavior = Math.random();
                    // Aplica velocidade da dificuldade
                    bot.speed = settings.botSpeed;
                    bot.baseSpeed = settings.botSpeed;
                    bots.push(bot);
                }
            }
        }

        function getAliveCount() {
            let count = player.alive ? 1 : 0;
            count += bots.filter(b => b.alive).length;
            return count;
        }

        function checkVictory() {
            const aliveCount = getAliveCount();
            const aliveBots = bots.filter(b => b.alive).length;
            
            // Se player morreu, calcula posi√ß√£o
            if (!player.alive && playerPlace === 0) {
                playerPlace = aliveCount + 1;
            }
            
            // Se s√≥ sobrou 1 (ou 0)
            if (aliveCount <= 1) {
                if (player.alive) {
                    // Player venceu!
                    playerPlace = 1;
                }
                return true;
            }
            return false;
        }

        function updateBots() {
            const settings = DIFFICULTY_SETTINGS[difficulty];
            
            for (let bot of bots) {
                if (!bot.alive) continue;

                const head = bot.segments[0];
                let targetX = head.x;
                let targetY = head.y;
                let priority = 'food';

                // === BUSCAR COMIDA (apenas dentro do raio de percep√ß√£o) ===
                let nearestFood = null;
                let nearestFoodDist = Infinity;
                for (let food of foods) {
                    const dist = Math.hypot(food.x - head.x, food.y - head.y);
                    if (dist < nearestFoodDist && dist < settings.botAwareness * 2) {
                        nearestFoodDist = dist;
                        nearestFood = food;
                    }
                }

                // === BUSCAR POWER-UPS ===
                let nearestPowerUp = null;
                let nearestPowerUpDist = Infinity;
                if (Math.random() < settings.botPowerUpPriority) {
                    for (let pu of powerUps) {
                        const dist = Math.hypot(pu.x - head.x, pu.y - head.y);
                        if (dist < nearestPowerUpDist && dist < settings.botAwareness * 1.5) {
                            nearestPowerUpDist = dist;
                            nearestPowerUp = pu;
                        }
                    }
                }

                // === AN√ÅLISE DO PLAYER ===
                const playerHead = player.alive ? player.segments[0] : null;
                const playerDist = playerHead ? Math.hypot(playerHead.x - head.x, playerHead.y - head.y) : Infinity;
                const isStronger = bot.maxSize > (player.maxSize || 0) + 3;
                const isWeaker = bot.maxSize < (player.maxSize || 0) - 5;
                const canSeePlayer = playerDist < settings.botAwareness;

                // === DETECTAR PROJ√âTEIS ===
                let incomingProjectile = null;
                let projectileDanger = 0;
                for (let proj of projectiles) {
                    if (proj.owner === bot) continue;
                    const projDist = Math.hypot(proj.x - head.x, proj.y - head.y);
                    if (projDist < 120 + settings.botAwareness * 0.3) {
                        const projToBot = Math.atan2(head.y - proj.y, head.x - proj.x);
                        let angleDiff = Math.abs(proj.angle - projToBot);
                        if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;
                        if (angleDiff < Math.PI / 2.5) {
                            incomingProjectile = proj;
                            projectileDanger = (150 - projDist) / 150;
                            break;
                        }
                    }
                }

                // === DETECTAR PERIGO DE COLIS√ÉO COM OUTROS ===
                let collisionDanger = null;
                for (let other of [...bots, player]) {
                    if (other === bot || !other.alive) continue;
                    for (let i = 0; i < Math.min(15, other.segments.length); i++) {
                        const seg = other.segments[i];
                        const segDist = Math.hypot(seg.x - head.x, seg.y - head.y);
                        // Verifica se est√° indo na dire√ß√£o do segmento
                        const toSeg = Math.atan2(seg.y - head.y, seg.x - head.x);
                        let dirDiff = Math.abs(bot.angle - toSeg);
                        if (dirDiff > Math.PI) dirDiff = Math.PI * 2 - dirDiff;
                        
                        if (segDist < 50 && dirDiff < Math.PI / 2) {
                            collisionDanger = { x: seg.x, y: seg.y, dist: segDist };
                            break;
                        }
                    }
                    if (collisionDanger) break;
                }

                // === DECIS√ïES DE IA ===
                
                // 1. EMERG√äNCIA: Desviar de colis√£o iminente
                if (collisionDanger && collisionDanger.dist < 35 && Math.random() < settings.botDodgeChance + 0.3) {
                    priority = 'emergency';
                    const awayAngle = Math.atan2(head.y - collisionDanger.y, head.x - collisionDanger.x);
                    targetX = head.x + Math.cos(awayAngle) * 80;
                    targetY = head.y + Math.sin(awayAngle) * 80;
                    
                    if (bot.powers.ghost.ready && Math.random() < 0.4) {
                        bot.usePower('ghost');
                    }
                }
                // 2. Desviar de proj√©teis
                else if (incomingProjectile && Math.random() < settings.botDodgeChance * (1 + projectileDanger)) {
                    priority = 'dodge';
                    const dodgeDir = Math.random() < 0.5 ? 1 : -1;
                    const dodgeAngle = incomingProjectile.angle + (Math.PI / 2) * dodgeDir;
                    targetX = head.x + Math.cos(dodgeAngle) * (80 + projectileDanger * 50);
                    targetY = head.y + Math.sin(dodgeAngle) * (80 + projectileDanger * 50);
                    
                    if (projectileDanger > 0.6 && bot.powers.shield.ready) {
                        bot.usePower('shield');
                    }
                }
                // 3. Buscar power-ups (prioridade alta em dificuldades altas)
                else if (nearestPowerUp && nearestPowerUpDist < 200) {
                    priority = 'powerup';
                    targetX = nearestPowerUp.x;
                    targetY = nearestPowerUp.y;
                    
                    if (nearestPowerUpDist < 100 && bot.powers.boost.ready && Math.random() < 0.4) {
                        bot.usePower('boost');
                    }
                }
                // 4. Atacar player se for mais forte
                else if (canSeePlayer && isStronger && Math.random() < settings.botAggression) {
                    priority = 'attack';
                    
                    // PREVIS√ÉO DE MOVIMENTO com precis√£o baseada na dificuldade
                    if (settings.botPrediction > 0 && playerHead) {
                        const playerSpeed = player.powers.boost.active ? player.speed * 2.5 : player.speed;
                        const travelTime = playerDist / 18;
                        const prediction = travelTime * settings.botPrediction * settings.botFireAccuracy;
                        targetX = playerHead.x + Math.cos(player.angle) * playerSpeed * prediction * 8;
                        targetY = playerHead.y + Math.sin(player.angle) * playerSpeed * prediction * 8;
                    } else {
                        targetX = playerHead.x;
                        targetY = playerHead.y;
                    }
                    
                    // FLANQUEAR
                    if (Math.random() < settings.botFlankChance && playerDist < 180) {
                        const flankDir = Math.random() < 0.5 ? 1 : -1;
                        const flankAngle = player.angle + (Math.PI / 2) * flankDir;
                        targetX = playerHead.x + Math.cos(flankAngle) * 70;
                        targetY = playerHead.y + Math.sin(flankAngle) * 70;
                    }
                    
                    // ARMAR ARMADILHA - ficar na frente do player
                    if (Math.random() < settings.botTrapChance && playerDist < 200) {
                        const trapDist = 60 + Math.random() * 40;
                        targetX = playerHead.x + Math.cos(player.angle) * trapDist;
                        targetY = playerHead.y + Math.sin(player.angle) * trapDist;
                    }
                    
                    // ATIRAR com mira inteligente
                    if (playerDist < 160 && bot.powers.fireball.ready) {
                        const aimAccuracy = settings.botFireAccuracy;
                        const distFactor = 1 - (playerDist / 200);
                        const fireChance = settings.botFireChance * (1 + distFactor) * (0.5 + aimAccuracy * 0.5);
                        
                        if (Math.random() < fireChance) {
                            // Ajustar mira com previs√£o
                            if (settings.botPrediction > 0.3) {
                                const aimX = targetX + (Math.random() - 0.5) * (1 - aimAccuracy) * 50;
                                const aimY = targetY + (Math.random() - 0.5) * (1 - aimAccuracy) * 50;
                                bot.angle = Math.atan2(aimY - head.y, aimX - head.x);
                            }
                            bot.usePower('fireball');
                        }
                    }
                    
                    if (playerDist < 100 && bot.powers.boost.ready && Math.random() < 0.25) {
                        bot.usePower('boost');
                    }
                }
                // 5. Fugir se for mais fraco
                else if (canSeePlayer && isWeaker && playerDist < 120) {
                    priority = 'flee';
                    const fleeAngle = Math.atan2(head.y - playerHead.y, head.x - playerHead.x);
                    targetX = head.x + Math.cos(fleeAngle) * 150;
                    targetY = head.y + Math.sin(fleeAngle) * 150;
                    
                    if (playerDist < 60) {
                        if (bot.powers.ghost.ready && Math.random() < 0.4) {
                            bot.usePower('ghost');
                        } else if (bot.powers.shield.ready && Math.random() < 0.3) {
                            bot.usePower('shield');
                        } else if (bot.powers.boost.ready && Math.random() < 0.3) {
                            bot.usePower('boost');
                        }
                    }
                }
                // 6. Buscar comida
                else if (nearestFood) {
                    priority = 'food';
                    targetX = nearestFood.x;
                    targetY = nearestFood.y;
                }

                // === TRABALHO EM EQUIPE ===
                if (settings.botTeamUp && canSeePlayer && playerDist < 250) {
                    let alliesNearPlayer = 0;
                    for (let ally of bots) {
                        if (ally === bot || !ally.alive) continue;
                        const allyToPlayer = Math.hypot(playerHead.x - ally.segments[0].x, playerHead.y - ally.segments[0].y);
                        if (allyToPlayer < 200) alliesNearPlayer++;
                    }
                    
                    if (alliesNearPlayer >= 2 && Math.random() < 0.5) {
                        // Atacar de √¢ngulo diferente dos aliados
                        const myAngle = Math.atan2(head.y - playerHead.y, head.x - playerHead.x);
                        targetX = playerHead.x + Math.cos(myAngle + Math.PI) * 80;
                        targetY = playerHead.y + Math.sin(myAngle + Math.PI) * 80;
                    }
                }

                // === DESVIAR DE OBST√ÅCULOS ===
                for (let rock of rocks) {
                    const rockDist = Math.hypot(rock.x - head.x, rock.y - head.y);
                    if (rockDist < rock.radius + 45) {
                        const awayAngle = Math.atan2(head.y - rock.y, head.x - rock.x);
                        targetX = head.x + Math.cos(awayAngle) * 90;
                        targetY = head.y + Math.sin(awayAngle) * 90;
                        break;
                    }
                }

                // Safe zone
                const safeDist = Math.hypot(head.x - safeZone.x, head.y - safeZone.y);
                if (safeDist > safeZone.currentRadius - 70) {
                    targetX = safeZone.x;
                    targetY = safeZone.y;
                    if (safeZone.shrinking && bot.powers.boost.ready) {
                        bot.usePower('boost');
                    }
                }

                // Bordas
                const margin = 60;
                if (head.x < margin) targetX = head.x + 100;
                if (head.x > WORLD_WIDTH - margin) targetX = head.x - 100;
                if (head.y < margin) targetY = head.y + 100;
                if (head.y > WORLD_HEIGHT - margin) targetY = head.y - 100;

                // === APLICAR MOVIMENTO ===
                let desiredAngle = Math.atan2(targetY - head.y, targetX - head.x);
                let angleDiff = desiredAngle - bot.angle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                bot.targetAngle = bot.angle + angleDiff * settings.botReaction;
                
                bot.update();
            }
        }

        function checkCollisions() {
            if (!player.alive) return;

            const playerHead = player.segments[0];

            // Colis√£o do player com pedras
            if (!player.powers.ghost.active && !player.powers.star.active) {
                const rockHit = checkRockCollision(playerHead.x, playerHead.y, 12);
                if (rockHit) {
                    createExplosion(playerHead.x, playerHead.y, '#888888', 20);
                    player.die();
                    return;
                }
            }

            // Colis√£o dos bots com pedras
            for (let bot of bots) {
                if (!bot.alive) continue;
                if (bot.powers.ghost.active || bot.powers.star.active) continue;
                
                const botHead = bot.segments[0];
                const rockHit = checkRockCollision(botHead.x, botHead.y, 12);
                if (rockHit) {
                    createExplosion(botHead.x, botHead.y, '#888888', 15);
                    bot.die();
                }
            }

            // Proj√©teis vs pedras
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                const rockHit = checkRockCollision(proj.x, proj.y, proj.radius);
                if (rockHit) {
                    createExplosion(proj.x, proj.y, '#ff6600', 8);
                    projectiles.splice(i, 1);
                }
            }

            for (let i = foods.length - 1; i >= 0; i--) {
                const food = foods[i];
                const dist = Math.hypot(food.x - playerHead.x, food.y - playerHead.y);
                if (dist < 18) {
                    player.maxSize += food.value;
                    foods.splice(i, 1);
                }
            }

            for (let bot of bots) {
                if (!bot.alive) continue;
                const botHead = bot.segments[0];
                for (let i = foods.length - 1; i >= 0; i--) {
                    const food = foods[i];
                    const dist = Math.hypot(food.x - botHead.x, food.y - botHead.y);
                    if (dist < 15) {
                        bot.maxSize += food.value;
                        foods.splice(i, 1);
                    }
                }
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                let projectileHit = false;
                
                // Verifica colis√£o com o player
                if (proj.owner !== player && !player.powers.ghost.active && !player.powers.star.active) {
                    const playerHead = player.segments[0];
                    
                    // REFLEX√ÉO DO ESCUDO - verifica se o proj√©til est√° perto e o escudo est√° ativo
                    if (player.powers.shield.active) {
                        const distToHead = Math.hypot(proj.x - playerHead.x, proj.y - playerHead.y);
                        if (distToHead < 35) {
                            // Reflete o proj√©til!
                            // Calcula √¢ngulo de reflex√£o (perpendicular ao √¢ngulo de chegada)
                            const incomingAngle = Math.atan2(playerHead.y - proj.y, playerHead.x - proj.x);
                            const reflectAngle = incomingAngle + Math.PI + (Math.random() - 0.5) * 0.5; // Adiciona varia√ß√£o
                            
                            proj.angle = reflectAngle;
                            proj.owner = player; // Agora pertence ao player
                            proj.color = '#00ffff'; // Cor ciano para indicar reflex√£o
                            
                            // Afasta o proj√©til do player
                            proj.x = playerHead.x + Math.cos(reflectAngle) * 40;
                            proj.y = playerHead.y + Math.sin(reflectAngle) * 40;
                            
                            // Efeitos visuais
                            createExplosion(playerHead.x, playerHead.y, '#00ffff', 12);
                            createShockwave(playerHead.x, playerHead.y, '#00d4ff');
                            triggerScreenShake(5);
                            triggerScreenFlash('#00ffff', 0.2);
                            
                            continue; // N√£o remove o proj√©til, ele foi refletido
                        }
                    }
                    
                    // Dano normal se n√£o tiver escudo
                    if (!player.powers.shield.active) {
                        for (let seg of player.segments) {
                            const dist = Math.hypot(proj.x - seg.x, proj.y - seg.y);
                            if (dist < 18) {
                                player.maxSize = Math.max(5, player.maxSize - proj.damage);
                                createExplosion(proj.x, proj.y, '#ff0000', 15);
                                showDamageIndicator(proj.x, proj.y, proj.damage, '#ff4444');
                                triggerScreenShake(8);
                                triggerScreenFlash('#ff0000', 0.3);
                                projectileHit = true;
                                break;
                            }
                        }
                        if (projectileHit) {
                            projectiles.splice(i, 1);
                            continue;
                        }
                    }
                }

                // Verifica colis√£o com TODOS os segmentos dos bots
                for (let bot of bots) {
                    if (!bot.alive || proj.owner === bot) continue;
                    
                    const botHead = bot.segments[0];
                    
                    // REFLEX√ÉO DO ESCUDO DO BOT
                    if (bot.powers.shield.active) {
                        const distToHead = Math.hypot(proj.x - botHead.x, proj.y - botHead.y);
                        if (distToHead < 35) {
                            // Reflete o proj√©til!
                            const incomingAngle = Math.atan2(botHead.y - proj.y, botHead.x - proj.x);
                            const reflectAngle = incomingAngle + Math.PI + (Math.random() - 0.5) * 0.5;
                            
                            proj.angle = reflectAngle;
                            proj.owner = bot;
                            proj.color = '#00ffff';
                            
                            proj.x = botHead.x + Math.cos(reflectAngle) * 40;
                            proj.y = botHead.y + Math.sin(reflectAngle) * 40;
                            
                            createExplosion(botHead.x, botHead.y, '#00ffff', 10);
                            
                            projectileHit = false; // N√£o foi hit, foi refletido
                            break;
                        }
                        continue; // Escudo ativo, pula verifica√ß√£o de dano
                    }
                    
                    if (bot.powers.ghost.active || bot.powers.star.active) continue;
                    
                    for (let seg of bot.segments) {
                        const dist = Math.hypot(proj.x - seg.x, proj.y - seg.y);
                        if (dist < 18) {
                            bot.maxSize = Math.max(5, bot.maxSize - proj.damage);
                            createExplosion(proj.x, proj.y, '#ff6600', 12);
                            showDamageIndicator(proj.x, proj.y, proj.damage, '#ff6600');
                            if (proj.owner === player) {
                                triggerScreenShake(3);
                            }
                            projectileHit = true;
                            break;
                        }
                    }
                    if (projectileHit) break;
                }
                
                if (projectileHit) {
                    projectiles.splice(i, 1);
                }
            }

            for (let bot of bots) {
                if (!bot.alive) continue;

                // Star power permite atravessar sem morrer e sem matar
                if (!player.powers.ghost.active && !player.powers.shield.active && !player.powers.star.active) {
                    for (let i = 1; i < bot.segments.length; i++) {
                        const seg = bot.segments[i];
                        const dist = Math.hypot(seg.x - playerHead.x, seg.y - playerHead.y);
                        if (dist < 16) {
                            player.die();
                            return;
                        }
                    }
                }

                const botHead = bot.segments[0];
                // Se star ativo, n√£o mata os outros tamb√©m
                if (!bot.powers.ghost.active && !player.powers.star.active) {
                    for (let i = 1; i < player.segments.length; i++) {
                        const seg = player.segments[i];
                        const dist = Math.hypot(seg.x - botHead.x, seg.y - botHead.y);
                        if (dist < 16) {
                            bot.die();
                            kills++;
                            triggerScreenShake(6);
                            triggerScreenFlash('#00ff88', 0.2);
                            break;
                        }
                    }
                }

                // Star ativo = atravessa sem consequ√™ncias
                if (!player.powers.ghost.active && !bot.powers.ghost.active && !player.powers.star.active) {
                    const headDist = Math.hypot(botHead.x - playerHead.x, botHead.y - playerHead.y);
                    if (headDist < 22) {
                        if (player.maxSize > bot.maxSize) {
                            bot.die();
                            kills++;
                            triggerScreenShake(8);
                            triggerScreenFlash('#00ff88', 0.25);
                        } else if (bot.maxSize > player.maxSize && !player.powers.shield.active) {
                            player.die();
                        }
                    }
                }
            }

            // Bot vs Bot
            for (let i = 0; i < bots.length; i++) {
                for (let j = i + 1; j < bots.length; j++) {
                    const bot1 = bots[i];
                    const bot2 = bots[j];
                    if (!bot1.alive || !bot2.alive) continue;
                    if (bot1.powers.ghost.active || bot2.powers.ghost.active) continue;

                    const head1 = bot1.segments[0];
                    const head2 = bot2.segments[0];

                    for (let k = 1; k < bot2.segments.length; k++) {
                        const dist = Math.hypot(bot2.segments[k].x - head1.x, bot2.segments[k].y - head1.y);
                        if (dist < 15) {
                            bot1.die();
                            break;
                        }
                    }

                    if (bot2.alive) {
                        for (let k = 1; k < bot1.segments.length; k++) {
                            const dist = Math.hypot(bot1.segments[k].x - head2.x, bot1.segments[k].y - head2.y);
                            if (dist < 15) {
                                bot2.die();
                                break;
                            }
                        }
                    }
                }
            }
            
            // DANO POR CONTATO DA ESTRELA
            if (player.alive && player.powers.star.active) {
                player.powers.star.damageTimer -= 16; // ~16ms por frame
                
                if (player.powers.star.damageTimer <= 0) {
                    player.powers.star.damageTimer = 1000; // Reset 1 segundo
                    
                    const playerHead = player.segments[0];
                    
                    // Verifica contato com cada bot
                    for (let bot of bots) {
                        if (!bot.alive) continue;
                        
                        // Verifica se qualquer segmento do player est√° tocando o bot
                        let isOverlapping = false;
                        for (let playerSeg of player.segments) {
                            for (let botSeg of bot.segments) {
                                const dist = Math.hypot(playerSeg.x - botSeg.x, playerSeg.y - botSeg.y);
                                if (dist < 25) {
                                    isOverlapping = true;
                                    break;
                                }
                            }
                            if (isOverlapping) break;
                        }
                        
                        if (isOverlapping) {
                            // Causa 1 de dano
                            const oldSize = bot.maxSize;
                            bot.maxSize = Math.max(5, bot.maxSize - 1);
                            
                            // Mostra indicador de dano
                            const botHead = bot.segments[0];
                            showDamageIndicator(botHead.x, botHead.y, 1, '#ffff00');
                            
                            // Efeito visual
                            createSparkles(botHead.x, botHead.y, '#ffff00', 5);
                            
                            // Se ficar muito pequeno, morre
                            if (bot.maxSize <= 5) {
                                bot.die();
                                kills++;
                                triggerScreenShake(4);
                                triggerScreenFlash('#ffff00', 0.15);
                            }
                        }
                    }
                }
            }
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                proj.x += Math.cos(proj.angle) * proj.speed;
                proj.y += Math.sin(proj.angle) * proj.speed;

                // Criar rastro de fogo
                if (Math.random() < 0.6) {
                    createTrail(
                        proj.x + (Math.random() - 0.5) * 10, 
                        proj.y + (Math.random() - 0.5) * 10, 
                        Math.random() < 0.5 ? '#ff6600' : '#ffaa00',
                        4 + Math.random() * 4
                    );
                }

                if (proj.x < 0 || proj.x > WORLD_WIDTH || proj.y < 0 || proj.y > WORLD_HEIGHT) {
                    createExplosion(proj.x, proj.y, '#ff4400', 8);
                    projectiles.splice(i, 1);
                }
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                
                if (p.type === 'shockwave') {
                    p.radius += (p.maxRadius - p.radius) * 0.2;
                    p.life--;
                } else {
                    if (p.vx !== undefined) {
                        p.x += p.vx;
                        p.y += p.vy;
                        p.vx *= 0.94;
                        p.vy *= 0.94;
                    }
                    p.life--;
                }
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function updateCamera() {
            if (!player.alive) return;
            const head = player.segments[0];
            camera.x = head.x - canvas.width / 2 + screenShake.x;
            camera.y = head.y - canvas.height / 2 + screenShake.y;
        }

        // ==================== SAFE ZONE ====================
        
        function updateSafeZone() {
            gameTime += 16;
            
            // Fases de fechamento
            const phases = [
                { time: 15000, radius: 900, waitTime: 10000 },
                { time: 35000, radius: 650, waitTime: 8000 },
                { time: 55000, radius: 450, waitTime: 8000 },
                { time: 75000, radius: 300, waitTime: 6000 },
                { time: 95000, radius: 200, waitTime: 6000 },
            ];
            
            const currentPhase = phases[safeZone.phase];
            
            if (currentPhase && gameTime >= currentPhase.time && !safeZone.warningShown) {
                safeZone.warningShown = true;
                safeZone.nextShrinkTime = gameTime + currentPhase.waitTime;
                triggerScreenFlash('#ff4444', 0.3);
            }
            
            if (safeZone.warningShown && gameTime >= safeZone.nextShrinkTime && !safeZone.shrinking) {
                safeZone.shrinking = true;
                safeZone.targetRadius = currentPhase.radius;
            }
            
            if (safeZone.shrinking) {
                safeZone.currentRadius -= safeZone.shrinkSpeed;
                if (safeZone.currentRadius <= safeZone.targetRadius) {
                    safeZone.currentRadius = safeZone.targetRadius;
                    safeZone.shrinking = false;
                    safeZone.warningShown = false;
                    safeZone.phase++;
                    
                    // Quando atinge o raio m√≠nimo, come√ßa a se mover
                    if (safeZone.currentRadius <= safeZone.minRadius) {
                        safeZone.moving = true;
                        setNewMoveTarget();
                    }
                }
            }
            
            // Movimento da safe zone quando atinge tamanho m√≠nimo
            if (safeZone.moving) {
                safeZone.moveTimer += 16;
                
                // Muda de dire√ß√£o periodicamente
                if (safeZone.moveTimer >= safeZone.moveInterval) {
                    safeZone.moveTimer = 0;
                    setNewMoveTarget();
                }
                
                // Move suavemente em dire√ß√£o ao alvo
                const dx = safeZone.moveTargetX - safeZone.x;
                const dy = safeZone.moveTargetY - safeZone.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 5) {
                    safeZone.x += (dx / dist) * safeZone.moveSpeed;
                    safeZone.y += (dy / dist) * safeZone.moveSpeed;
                }
            }
            
            // Dano fora da safe zone
            safeZone.damageTimer += 16;
            if (safeZone.damageTimer >= 500) {
                safeZone.damageTimer = 0;
                
                if (player.alive) {
                    const playerDist = Math.hypot(player.segments[0].x - safeZone.x, player.segments[0].y - safeZone.y);
                    if (playerDist > safeZone.currentRadius) {
                        player.maxSize = Math.max(3, player.maxSize - 1);
                        showDamageIndicator(player.segments[0].x, player.segments[0].y, 1, '#ff4444');
                        triggerScreenFlash('#ff0000', 0.15);
                        createExplosion(player.segments[0].x, player.segments[0].y, '#ff0000', 5);
                        if (player.maxSize <= 3) {
                            player.die();
                        }
                    }
                }
                
                for (let bot of bots) {
                    if (!bot.alive) continue;
                    const botDist = Math.hypot(bot.segments[0].x - safeZone.x, bot.segments[0].y - safeZone.y);
                    if (botDist > safeZone.currentRadius) {
                        bot.maxSize = Math.max(3, bot.maxSize - 1);
                        showDamageIndicator(bot.segments[0].x, bot.segments[0].y, 1, '#ff4444');
                        if (bot.maxSize <= 3) {
                            bot.die();
                        }
                    }
                }
            }
        }

        function setNewMoveTarget() {
            // Define um novo alvo para a safe zone se mover
            // Mant√©m dentro dos limites do mapa com margem
            const margin = safeZone.currentRadius + 100;
            safeZone.moveTargetX = margin + Math.random() * (WORLD_WIDTH - margin * 2);
            safeZone.moveTargetY = margin + Math.random() * (WORLD_HEIGHT - margin * 2);
        }

        function drawSafeZone() {
            const sx = safeZone.x - camera.x;
            const sy = safeZone.y - camera.y;
            
            // √Årea fora da safe zone (vermelha perigosa)
            ctx.fillStyle = 'rgba(255, 0, 0, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Limpa a √°rea segura
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.arc(sx, sy, safeZone.currentRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Borda da safe zone
            const pulse = Math.sin(Date.now() * 0.005) * 3;
            
            // Borda externa (warning) - mostra para onde vai
            if (safeZone.shrinking || safeZone.warningShown) {
                ctx.beginPath();
                ctx.arc(sx, sy, safeZone.targetRadius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 3;
                ctx.setLineDash([20, 10]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Indicador de dire√ß√£o quando est√° se movendo
            if (safeZone.moving) {
                const targetSx = safeZone.moveTargetX - camera.x;
                const targetSy = safeZone.moveTargetY - camera.y;
                
                // Linha pontilhada mostrando dire√ß√£o
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(targetSx, targetSy);
                ctx.strokeStyle = 'rgba(255, 200, 0, 0.4)';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 10]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // C√≠rculo no destino
                ctx.beginPath();
                ctx.arc(targetSx, targetSy, 20, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 200, 0, 0.6)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Borda atual
            ctx.beginPath();
            ctx.arc(sx, sy, safeZone.currentRadius + pulse, 0, Math.PI * 2);
            
            // Cor diferente quando est√° se movendo
            let borderColor = '#00aaff';
            if (safeZone.shrinking) {
                borderColor = '#ff4444';
            } else if (safeZone.moving) {
                borderColor = '#ffaa00';
            }
            
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // Efeito de eletricidade/part√≠culas na borda
            if (safeZone.shrinking || safeZone.moving) {
                const particleCount = safeZone.moving ? 12 : 8;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Date.now() * 0.002 + i * Math.PI * 2 / particleCount) % (Math.PI * 2);
                    const bx = sx + Math.cos(angle) * safeZone.currentRadius;
                    const by = sy + Math.sin(angle) * safeZone.currentRadius;
                    
                    ctx.beginPath();
                    ctx.arc(bx, by, 4 + Math.random() * 4, 0, Math.PI * 2);
                    if (safeZone.moving) {
                        ctx.fillStyle = `rgba(255, ${180 + Math.random() * 75}, 0, ${0.5 + Math.random() * 0.5})`;
                    } else {
                        ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${0.5 + Math.random() * 0.5})`;
                    }
                    ctx.fill();
                }
            }
        }

        function drawSafeZoneUI() {
            // Timer e aviso
            const timeLeft = Math.max(0, Math.ceil((safeZone.nextShrinkTime - gameTime) / 1000));
            
            if (safeZone.moving) {
                ctx.fillStyle = 'rgba(255, 150, 0, 0.9)';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üîÑ ZONA EM MOVIMENTO! üîÑ', canvas.width / 2, 50);
            } else if (safeZone.warningShown && !safeZone.shrinking) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`‚ö†Ô∏è ZONA FECHANDO EM ${timeLeft}s ‚ö†Ô∏è`, canvas.width / 2, 50);
            } else if (safeZone.shrinking) {
                ctx.fillStyle = 'rgba(255, 100, 0, 0.9)';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üî¥ ZONA FECHANDO! üî¥', canvas.width / 2, 50);
            }
        }

        function drawBackground() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            const offsetX = -camera.x % gridSize;
            const offsetY = -camera.y % gridSize;

            for (let x = offsetX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = offsetY; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawFood() {
            for (let food of foods) {
                const sx = food.x - camera.x;
                const sy = food.y - camera.y;
                
                if (sx < -20 || sx > canvas.width + 20 || sy < -20 || sy > canvas.height + 20) continue;

                ctx.beginPath();
                ctx.arc(sx, sy, food.radius + 3, 0, Math.PI * 2);
                ctx.fillStyle = food.color + '33';
                ctx.fill();

                ctx.beginPath();
                ctx.arc(sx, sy, food.radius, 0, Math.PI * 2);
                ctx.fillStyle = food.color;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(sx - 2, sy - 2, food.radius / 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fill();
            }
        }

        function drawProjectiles() {
            for (let proj of projectiles) {
                const sx = proj.x - camera.x;
                const sy = proj.y - camera.y;

                // Brilho externo
                ctx.beginPath();
                ctx.arc(sx, sy, proj.radius + 15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 100, 0, 0.2)';
                ctx.fill();

                // Brilho m√©dio
                ctx.beginPath();
                ctx.arc(sx, sy, proj.radius + 8, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 150, 0, 0.4)';
                ctx.fill();

                // N√∫cleo com gradiente
                const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, proj.radius);
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(0.3, '#ffff00');
                gradient.addColorStop(0.6, '#ff6600');
                gradient.addColorStop(1, '#ff0000');
                
                ctx.beginPath();
                ctx.arc(sx, sy, proj.radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Brilho central
                ctx.beginPath();
                ctx.arc(sx, sy, proj.radius * 0.4, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fill();
            }
        }

        function drawParticles() {
            for (let p of particles) {
                const sx = p.x - camera.x;
                const sy = p.y - camera.y;
                
                if (p.type === 'shockwave') {
                    // Desenha onda de choque
                    const alpha = p.life / 20;
                    ctx.beginPath();
                    ctx.arc(sx, sy, p.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = 4 * alpha;
                    ctx.globalAlpha = alpha;
                    ctx.stroke();
                    
                    // Segunda onda
                    ctx.beginPath();
                    ctx.arc(sx, sy, p.radius * 0.7, 0, Math.PI * 2);
                    ctx.lineWidth = 2 * alpha;
                    ctx.globalAlpha = alpha * 0.5;
                    ctx.stroke();
                } else if (p.type === 'sparkle') {
                    // Brilhos com formato de estrela
                    const alpha = p.life / 35;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    
                    // Desenha estrela
                    ctx.save();
                    ctx.translate(sx, sy);
                    ctx.rotate(p.life * 0.1);
                    ctx.beginPath();
                    for (let i = 0; i < 4; i++) {
                        const angle = (Math.PI / 2) * i;
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * p.size * 2, Math.sin(angle) * p.size * 2);
                    }
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.restore();
                    
                    ctx.beginPath();
                    ctx.arc(sx, sy, p.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'trail') {
                    // Rastro de fogo
                    const alpha = p.life / 15;
                    ctx.globalAlpha = alpha;
                    
                    const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, p.size);
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.5, p.color);
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.beginPath();
                    ctx.arc(sx, sy, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                } else if (p.type === 'explosion') {
                    // Part√≠culas de explos√£o
                    const alpha = p.life / 50;
                    ctx.globalAlpha = alpha;
                    
                    const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, p.size);
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.4, p.color);
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.beginPath();
                    ctx.arc(sx, sy, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                } else if (p.type === 'damage') {
                    // Indicador de dano flutuante
                    const alpha = p.life / 45;
                    const scale = 1 + (1 - alpha) * 0.3;
                    
                    ctx.globalAlpha = alpha;
                    ctx.font = `bold ${p.size * scale}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Contorno
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 4;
                    ctx.strokeText(p.text, sx, sy);
                    
                    // Texto
                    ctx.fillStyle = p.color;
                    ctx.fillText(p.text, sx, sy);
                    
                    // Brilho
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 10;
                    ctx.fillText(p.text, sx, sy);
                    ctx.shadowBlur = 0;
                } else {
                    // Part√≠culas padr√£o
                    ctx.globalAlpha = p.life / 25;
                    ctx.beginPath();
                    ctx.arc(sx, sy, p.size || 5, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;
        }

        function drawMinimap() {
            minimapCtx.fillStyle = 'rgba(0,0,0,0.7)';
            minimapCtx.fillRect(0, 0, 90, 90);

            const scale = 90 / WORLD_WIDTH;

            // Pedras no minimap
            minimapCtx.fillStyle = '#555';
            for (let rock of rocks) {
                minimapCtx.beginPath();
                minimapCtx.arc(rock.x * scale, rock.y * scale, rock.radius * scale * 0.8, 0, Math.PI * 2);
                minimapCtx.fill();
            }

            minimapCtx.fillStyle = 'rgba(255,255,255,0.2)';
            for (let i = 0; i < foods.length; i += 3) {
                const food = foods[i];
                minimapCtx.fillRect(food.x * scale, food.y * scale, 1, 1);
            }

            for (let bot of bots) {
                if (!bot.alive) continue;
                minimapCtx.fillStyle = bot.color;
                minimapCtx.beginPath();
                minimapCtx.arc(bot.segments[0].x * scale, bot.segments[0].y * scale, 2, 0, Math.PI * 2);
                minimapCtx.fill();
            }

            if (player.alive) {
                minimapCtx.fillStyle = '#00ff88';
                minimapCtx.beginPath();
                minimapCtx.arc(player.segments[0].x * scale, player.segments[0].y * scale, 3, 0, Math.PI * 2);
                minimapCtx.fill();
            }

            minimapCtx.strokeStyle = 'rgba(255,255,255,0.5)';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                camera.x * scale,
                camera.y * scale,
                canvas.width * scale,
                canvas.height * scale
            );
        }

        function updateUI() {
            document.getElementById('playerSize').textContent = player.maxSize;
            document.getElementById('kills').textContent = kills;

            // Power buttons
            const powerButtons = {
                boost: document.getElementById('btnBoost'),
                fireball: document.getElementById('btnFireball'),
                shield: document.getElementById('btnShield'),
                ghost: document.getElementById('btnGhost')
            };

            for (let powerName in powerButtons) {
                const btn = powerButtons[powerName];
                const power = player.powers[powerName];
                const overlay = btn.querySelector('.cooldown-overlay');
                
                if (power.ready) {
                    btn.classList.add('ready');
                    btn.classList.remove('cooldown');
                    overlay.style.height = '0%';
                } else {
                    btn.classList.remove('ready');
                    btn.classList.add('cooldown');
                    const progress = power.cooldown / POWER_COOLDOWNS[powerName];
                    overlay.style.height = (progress * 100) + '%';
                }
            }

            // Active power indicators
            document.getElementById('shieldIndicator').classList.toggle('show', player.powers.shield.active);
            document.getElementById('ghostIndicator').classList.toggle('show', player.powers.ghost.active);
            document.getElementById('starIndicator').classList.toggle('show', player.powers.star.active);
            
            // Double fire indicator - mostra total de proj√©teis
            const doubleFireCharges = player.powers.doubleFire.charges;
            const totalShots = 1 + doubleFireCharges;
            document.getElementById('doubleFireIndicator').classList.toggle('show', doubleFireCharges > 0);
            document.getElementById('doubleFireCharges').textContent = totalShots;

            // Leaderboard - Top 10
            const allSnakes = [player, ...bots].filter(s => s.alive).sort((a, b) => b.maxSize - a.maxSize);
            let leaderboardHTML = '';
            for (let i = 0; i < Math.min(10, allSnakes.length); i++) {
                const snake = allSnakes[i];
                const isPlayer = snake === player;
                leaderboardHTML += `<div class="leaderboard-entry ${isPlayer ? 'player' : ''}">
                    <span>${i + 1}. ${snake.name.substring(0, 7)}</span>
                    <span>${snake.maxSize}</span>
                </div>`;
            }
            document.getElementById('leaderboardContent').innerHTML = leaderboardHTML;
        }

        function gameLoop() {
            if (!gameRunning) return;
            if (typeof gamePaused !== 'undefined' && gamePaused) return;

            // Update player angle from joystick
            if (joystickActive && joystickDistance > 10) {
                player.targetAngle = joystickAngle;
            }

            player.update();
            updateBots();
            updateProjectiles();
            updateParticles();
            updateScreenEffects();
            updateSafeZone();
            checkCollisions();
            checkPowerUpCollision();
            collectCoins();
            updateCamera();
            spawnFood();
            spawnPowerUps();
            spawnCoins();
            spawnBots();

            // Efeitos de boost - rastro
            if (player.alive && player.powers.boost.active) {
                const head = player.segments[0];
                createTrail(head.x, head.y, '#feca57', 8);
            }

            // Efeitos de shield - part√≠culas
            if (player.alive && player.powers.shield.active && Math.random() < 0.3) {
                const head = player.segments[0];
                const angle = Math.random() * Math.PI * 2;
                createSparkles(
                    head.x + Math.cos(angle) * 20,
                    head.y + Math.sin(angle) * 20,
                    '#48dbfb', 1
                );
            }

            // Efeitos de ghost - part√≠culas fantasma
            if (player.alive && player.powers.ghost.active && Math.random() < 0.4) {
                const seg = player.segments[Math.floor(Math.random() * player.segments.length)];
                particles.push({
                    x: seg.x + (Math.random() - 0.5) * 20,
                    y: seg.y + (Math.random() - 0.5) * 20,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -1 - Math.random() * 2,
                    color: '#ff9ff3',
                    life: 20,
                    size: 3 + Math.random() * 4,
                    type: 'trail'
                });
            }

            // Efeitos de star - brilhos dourados intensos
            if (player.alive && player.powers.star.active) {
                const head = player.segments[0];
                // Rastro de estrelas
                if (Math.random() < 0.6) {
                    createTrail(head.x, head.y, '#ffdd00', 10);
                }
                // Sparkles em toda a cobra
                if (Math.random() < 0.5) {
                    const seg = player.segments[Math.floor(Math.random() * player.segments.length)];
                    createSparkles(seg.x, seg.y, Math.random() < 0.5 ? '#ffff00' : '#ffffff', 2);
                }
            }

            drawBackground();
            drawSafeZone();
            drawRocks();
            drawPowerUps();
            drawCoins();
            drawFood();
            drawProjectiles();
            for (let bot of bots) bot.draw();
            player.draw();
            drawParticles();
            drawScreenFlash();
            drawSafeZoneUI();
            drawAliveCount();
            drawMinimap();
            updateUI();

            // Verifica vit√≥ria (s√≥ sobrou 1)
            if (checkVictory()) {
                gameOver();
                return;
            }

            // Player morreu = game over imediato
            if (!player.alive) {
                gameOver();
                return;
            }

            requestAnimationFrame(gameLoop);
        }

        function drawAliveCount() {
            const alive = getAliveCount();
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(canvas.width / 2 - 50, 10, 100, 30);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`üêç ${alive} vivos`, canvas.width / 2, 30);
        }

        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');

            // Pega o nome do jogador do input
            const nameInput = document.getElementById('playerNameInput');
            playerName = nameInput.value.trim() || 'Jogador';
            localStorage.setItem('snakeBattleName', playerName);

            // Verifica se tem skin especial selecionada
            const skinData = SPECIAL_SKINS[selectedSkin];
            let useColors = playerColorSequence;
            let useRainbow = (playerColor === 'rainbow');
            
            if (selectedSkin !== 'default' && skinData && skinData.colors) {
                if (skinData.colors[0] === 'rainbow') {
                    useRainbow = true;
                    useColors = [];
                } else {
                    useRainbow = false;
                    useColors = skinData.colors;
                }
            }

            // Usa a cor/sequ√™ncia selecionada
            player = new Snake(WORLD_WIDTH / 2, WORLD_HEIGHT / 2, useRainbow ? 'rainbow' : (useColors[0] || playerColor), true);
            player.name = playerName;
            player.isRainbow = useRainbow;
            player.colorSequence = useColors.length > 0 ? [...useColors] : [];
            player.skinEffect = skinData ? skinData.effect : null;
            player.headType = skinData ? skinData.headType : null;
            
            bots = [];
            foods = [];
            projectiles = [];
            particles = [];
            powerUps = [];
            rocks = [];
            coins = [];
            kills = 0;
            playerPlace = 0;
            gameCoinsCollected = 0;
            camera = { x: 0, y: 0 };
            gameTime = 0;

            // Mostra HUD de moedas
            document.getElementById('coinsHud').classList.remove('hidden');
            document.getElementById('gameCoins').textContent = playerCoins;

            // Reset safe zone - ajustado para mapa maior
            safeZone = {
                x: WORLD_WIDTH / 2,
                y: WORLD_HEIGHT / 2,
                currentRadius: 1800,
                targetRadius: 1800,
                minRadius: 250,
                shrinkSpeed: 0.12,
                damageTimer: 0,
                phase: 0,
                nextShrinkTime: 0,
                shrinking: false,
                warningShown: false,
                moving: false,
                moveTargetX: WORLD_WIDTH / 2,
                moveTargetY: WORLD_HEIGHT / 2,
                moveSpeed: 0.3,
                moveTimer: 0,
                moveInterval: 8000
            };

            spawnRocks();
            spawnFood();
            spawnBots();

            gameRunning = true;
            if (typeof gamePaused !== 'undefined') gamePaused = false;
            if (typeof pauseMenu !== 'undefined') pauseMenu.classList.add('hidden');
            gameLoop();
        }

        function goToMainMenu() {
            gameRunning = false;
            gamePaused = false;
            pauseMenu.classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
            
            // Atualiza coroas no menu
            document.getElementById('displayCrowns').textContent = playerCrowns;
        }

        function gameOver() {
            gameRunning = false;
            
            // Calcula coroas ganhas ou perdidas
            let crownsChange = 0;
            let placeText = '';
            let placeEmoji = '';
            
            if (playerPlace === 1) {
                crownsChange = 10;
                placeText = '1¬∫ LUGAR - CAMPE√ÉO!';
                placeEmoji = 'üèÜ';
            } else if (playerPlace === 2) {
                crownsChange = 6;
                placeText = '2¬∫ LUGAR';
                placeEmoji = 'ü•à';
            } else if (playerPlace === 3) {
                crownsChange = 4;
                placeText = '3¬∫ LUGAR';
                placeEmoji = 'ü•â';
            } else if (playerPlace === 4) {
                crownsChange = 0; // 4¬∫ lugar n√£o ganha nem perde
                placeText = '4¬∫ LUGAR';
                placeEmoji = 'üòê';
            } else if (playerPlace >= 5 && playerPlace <= 20) {
                // 5¬∫ ao 20¬∫ perde coroas proporcionalmente
                // 5¬∫ perde 1, 6¬∫ perde 2, ..., 20¬∫ perde 16
                crownsChange = -(playerPlace - 4);
                placeText = `${playerPlace}¬∫ LUGAR`;
                placeEmoji = 'üíÄ';
            } else {
                placeText = `${playerPlace}¬∫ LUGAR`;
                placeEmoji = 'üíÄ';
            }
            
            // Aplica mudan√ßa de coroas (n√£o pode ficar negativo)
            if (crownsChange !== 0) {
                playerCrowns = Math.max(0, playerCrowns + crownsChange);
                saveCrowns();
            }
            
            // Atualiza UI
            document.getElementById('gameOverScreen').classList.remove('hidden');
            document.getElementById('finalPlace').textContent = `${placeEmoji} ${placeText}`;
            document.getElementById('finalPlace').style.color = playerPlace === 1 ? '#ffd700' : playerPlace === 2 ? '#c0c0c0' : playerPlace === 3 ? '#cd7f32' : playerPlace === 4 ? '#aaaaaa' : '#ff6b6b';
            
            // Mostra ganho ou perda de coroas
            if (crownsChange > 0) {
                document.getElementById('crownsEarned').textContent = `+${crownsChange} üëë`;
                document.getElementById('crownsEarned').style.color = '#ffd700';
            } else if (crownsChange < 0) {
                document.getElementById('crownsEarned').textContent = `${crownsChange} üëë`;
                document.getElementById('crownsEarned').style.color = '#ff4444';
            } else {
                document.getElementById('crownsEarned').textContent = '';
            }
            
            document.getElementById('totalCrowns').textContent = playerCrowns;
            document.getElementById('finalSize').textContent = player.maxSize;
            document.getElementById('finalKills').textContent = kills;
            
            // Esconde HUD de moedas
            document.getElementById('coinsHud').classList.add('hidden');
            
            // Atualiza moedas na tela principal
            document.getElementById('displayCoins').textContent = playerCoins;
        }

        // ==================== CONTROLES MOBILE ====================

        // Joystick Din√¢mico
        const joystickZone = document.getElementById('joystickZone');
        const joystickArea = document.getElementById('joystickArea');
        const joystickStick = document.getElementById('joystickStick');

        let joystickTouch = null;
        let joystickOriginX = 0;
        let joystickOriginY = 0;

        function updateJoystick(touchX, touchY) {
            const deltaX = touchX - joystickOriginX;
            const deltaY = touchY - joystickOriginY;
            
            joystickDistance = Math.min(Math.hypot(deltaX, deltaY), 50);
            joystickAngle = Math.atan2(deltaY, deltaX);
            
            const stickX = Math.cos(joystickAngle) * joystickDistance;
            const stickY = Math.sin(joystickAngle) * joystickDistance;
            
            joystickStick.style.left = `calc(50% + ${stickX}px)`;
            joystickStick.style.top = `calc(50% + ${stickY}px)`;
        }

        function resetJoystick() {
            joystickArea.classList.remove('active');
            joystickStick.style.left = '50%';
            joystickStick.style.top = '50%';
            joystickDistance = 0;
        }

        joystickZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (joystickTouch !== null) return; // J√° tem um toque ativo
            
            const touch = e.changedTouches[0];
            joystickTouch = touch.identifier;
            joystickActive = true;
            
            // Posiciona o joystick onde o player tocou
            joystickOriginX = touch.clientX;
            joystickOriginY = touch.clientY;
            
            // Centraliza o joystick no ponto de toque
            joystickArea.style.left = (joystickOriginX - 70) + 'px';
            joystickArea.style.top = (joystickOriginY - 70) + 'px';
            joystickArea.classList.add('active');
            
            updateJoystick(touch.clientX, touch.clientY);
        });

        joystickZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let touch of e.touches) {
                if (touch.identifier === joystickTouch) {
                    updateJoystick(touch.clientX, touch.clientY);
                    break;
                }
            }
        });

        joystickZone.addEventListener('touchend', (e) => {
            for (let touch of e.changedTouches) {
                if (touch.identifier === joystickTouch) {
                    joystickActive = false;
                    joystickTouch = null;
                    resetJoystick();
                    break;
                }
            }
        });

        joystickZone.addEventListener('touchcancel', (e) => {
            joystickActive = false;
            joystickTouch = null;
            resetJoystick();
        });

        // Power buttons
        const powerFeedback = document.getElementById('powerFeedback');
        const powerEmojis = {
            boost: '‚ö°',
            fireball: 'üî•',
            shield: 'üõ°Ô∏è',
            ghost: 'üëª'
        };

        function activatePower(powerName) {
            if (!player || !player.alive || !gameRunning) return;
            
            if (player.usePower(powerName)) {
                powerFeedback.textContent = powerEmojis[powerName];
                powerFeedback.classList.remove('show');
                void powerFeedback.offsetWidth; // Trigger reflow
                powerFeedback.classList.add('show');
            }
        }

        document.querySelectorAll('.power-btn').forEach(btn => {
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const power = btn.dataset.power;
                activatePower(power);
            });
        });

        // Start/Restart buttons
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('startBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            startGame();
        });

        document.getElementById('restartBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            startGame();
        });

        // Menu de Pausa
        let gamePaused = false;
        const pauseMenu = document.getElementById('pauseMenu');
        const menuBtn = document.getElementById('menuBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const quitBtn = document.getElementById('quitBtn');

        function togglePause() {
            if (!gameRunning && !gamePaused) return;
            
            gamePaused = !gamePaused;
            pauseMenu.classList.toggle('hidden', !gamePaused);
            
            if (!gamePaused && player && player.alive) {
                // Retomar o jogo
                gameLoop();
            }
        }

        function quitGame() {
            gamePaused = false;
            gameRunning = false;
            pauseMenu.classList.add('hidden');
            
            // Calcula posi√ß√£o do player (quantos est√£o vivos + 1)
            if (player && player.alive) {
                playerPlace = getAliveCount(); // Desistiu, ent√£o fica na posi√ß√£o atual
            }
            
            // Mostra game over com penalidade
            if (playerPlace === 0) playerPlace = totalBots + 1; // √öltimo lugar se desistiu
            gameOver();
        }

        menuBtn.addEventListener('click', togglePause);
        menuBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            togglePause();
        });

        resumeBtn.addEventListener('click', togglePause);
        resumeBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            togglePause();
        });

        quitBtn.addEventListener('click', quitGame);
        quitBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            quitGame();
        });

        // Bot√£o de menu principal no pause
        const mainMenuBtn = document.getElementById('mainMenuBtn');
        mainMenuBtn.addEventListener('click', goToMainMenu);
        mainMenuBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            goToMainMenu();
        });

        // Bot√£o de menu principal no game over
        const menuBtn2 = document.getElementById('menuBtn2');
        menuBtn2.addEventListener('click', goToMainMenu);
        menuBtn2.addEventListener('touchstart', (e) => {
            e.preventDefault();
            goToMainMenu();
        });

        // Prevent scrolling
        document.addEventListener('touchmove', (e) => {
            if (gameRunning) e.preventDefault();
        }, { passive: false });

        // Handle orientation
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100);
        });

        // Inicializa display de coroas
        document.getElementById('displayCrowns').textContent = playerCrowns;

        // Inicializa campo de nome
        document.getElementById('playerNameInput').value = playerName;

        // Seletor de dificuldade
        document.querySelectorAll('.diff-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                difficulty = btn.dataset.diff;
            });
            
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                difficulty = btn.dataset.diff;
            });
        });

        function lightenColorPreview(color, percent) {
            if (color.startsWith('hsl')) return color;
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        // ==================== SISTEMA DE PERSONALIZA√á√ÉO ====================
        
        const customizeScreen = document.getElementById('customizeScreen');
        const customizeBtn = document.getElementById('customizeBtn');
        const backFromCustomize = document.getElementById('backFromCustomize');
        const colorSlotsContainer = document.getElementById('colorSlots');
        const colorPaletteContainer = document.getElementById('colorPalette');
        const presetsGrid = document.getElementById('presetsGrid');
        const clearColorsBtn = document.getElementById('clearColorsBtn');
        const saveColorsBtn = document.getElementById('saveColorsBtn');
        
        let tempColorSequence = [...playerColorSequence];
        let selectedSlotIndex = 0;
        let largePreviewAnimFrame = 0;

        // Abrir tela de personaliza√ß√£o
        function openCustomizeScreen() {
            tempColorSequence = [...playerColorSequence];
            customizeScreen.classList.add('active');
            renderColorSlots();
            renderColorPalette();
            renderPresets();
            updateLargePreview();
        }

        // Fechar tela de personaliza√ß√£o
        function closeCustomizeScreen() {
            customizeScreen.classList.remove('active');
        }

        // Renderizar slots de cores
        function renderColorSlots() {
            colorSlotsContainer.innerHTML = '';
            for (let i = 0; i < 8; i++) {
                const slot = document.createElement('div');
                slot.className = 'color-slot' + (tempColorSequence[i] ? ' filled' : '') + (i === selectedSlotIndex ? ' selected' : '');
                
                if (tempColorSequence[i]) {
                    if (tempColorSequence[i] === 'rainbow') {
                        slot.style.background = 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #8b00ff)';
                    } else {
                        slot.style.background = tempColorSequence[i];
                    }
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-btn';
                    removeBtn.innerHTML = '√ó';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        removeColorFromSlot(i);
                    };
                    slot.appendChild(removeBtn);
                } else {
                    slot.innerHTML = '+';
                }
                
                slot.onclick = () => {
                    selectedSlotIndex = i;
                    renderColorSlots();
                };
                
                colorSlotsContainer.appendChild(slot);
            }
        }

        // Renderizar paleta de cores
        function renderColorPalette() {
            colorPaletteContainer.innerHTML = '';
            
            // Adiciona op√ß√£o rainbow primeiro
            const rainbowBtn = document.createElement('div');
            rainbowBtn.className = 'palette-color';
            rainbowBtn.style.background = 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #8b00ff)';
            rainbowBtn.onclick = () => addColorToSequence('rainbow');
            colorPaletteContainer.appendChild(rainbowBtn);
            
            COLOR_PALETTE.forEach(color => {
                const colorBtn = document.createElement('div');
                colorBtn.className = 'palette-color';
                colorBtn.style.background = color;
                colorBtn.onclick = () => addColorToSequence(color);
                colorPaletteContainer.appendChild(colorBtn);
            });
        }

        // Renderizar presets
        function renderPresets() {
            presetsGrid.innerHTML = '';
            COLOR_PRESETS.forEach(preset => {
                const presetBtn = document.createElement('div');
                presetBtn.className = 'preset-btn';
                
                const preview = document.createElement('div');
                preview.className = 'preset-preview';
                
                if (preset.colors[0] === 'rainbow') {
                    const dot = document.createElement('div');
                    dot.className = 'dot';
                    dot.style.width = '48px';
                    dot.style.background = 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #8b00ff)';
                    preview.appendChild(dot);
                } else {
                    preset.colors.forEach(color => {
                        const dot = document.createElement('div');
                        dot.className = 'dot';
                        dot.style.background = color;
                        preview.appendChild(dot);
                    });
                }
                
                const name = document.createElement('div');
                name.className = 'preset-name';
                name.textContent = preset.name;
                
                presetBtn.appendChild(preview);
                presetBtn.appendChild(name);
                
                presetBtn.onclick = () => applyPreset(preset);
                presetsGrid.appendChild(presetBtn);
            });
        }

        // Adicionar cor √† sequ√™ncia
        function addColorToSequence(color) {
            if (tempColorSequence.length < 8) {
                // Adiciona no slot selecionado ou no pr√≥ximo vazio
                if (selectedSlotIndex < tempColorSequence.length) {
                    tempColorSequence[selectedSlotIndex] = color;
                } else {
                    tempColorSequence.push(color);
                }
                selectedSlotIndex = Math.min(selectedSlotIndex + 1, 7);
                renderColorSlots();
            }
        }

        // Remover cor do slot
        function removeColorFromSlot(index) {
            tempColorSequence.splice(index, 1);
            selectedSlotIndex = Math.min(index, tempColorSequence.length);
            renderColorSlots();
        }

        // Aplicar preset
        function applyPreset(preset) {
            if (preset.colors[0] === 'rainbow') {
                tempColorSequence = ['rainbow'];
            } else {
                tempColorSequence = [...preset.colors];
            }
            selectedSlotIndex = tempColorSequence.length;
            renderColorSlots();
        }

        // Limpar cores
        function clearColors() {
            tempColorSequence = [];
            selectedSlotIndex = 0;
            renderColorSlots();
        }

        // Salvar e fechar
        function saveColors() {
            playerColorSequence = [...tempColorSequence];
            localStorage.setItem('snakeBattleColorSequence', JSON.stringify(playerColorSequence));
            
            // Atualiza playerColor baseado na sequ√™ncia
            if (playerColorSequence.length > 0) {
                if (playerColorSequence[0] === 'rainbow') {
                    playerColor = 'rainbow';
                } else {
                    playerColor = playerColorSequence[0];
                }
            }
            localStorage.setItem('snakeBattleColor', playerColor);
            
            closeCustomizeScreen();
        }

        // Preview grande animado
        function updateLargePreview() {
            const canvas = document.getElementById('snakePreviewLarge');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const segments = 12;
            const colors = tempColorSequence.length > 0 ? tempColorSequence : [playerColor || '#00ff88'];
            const isRainbow = colors[0] === 'rainbow';
            
            for (let i = segments - 1; i >= 0; i--) {
                const x = 30 + i * 25;
                const y = 60 + Math.sin((largePreviewAnimFrame + i * 15) * 0.05) * 15;
                const radius = 18 - i * 0.8;
                
                let segColor;
                if (isRainbow) {
                    const hue = (largePreviewAnimFrame * 2 + i * 25) % 360;
                    segColor = `hsl(${hue}, 100%, 50%)`;
                } else {
                    segColor = colors[i % colors.length];
                }
                
                // Sombra
                ctx.beginPath();
                ctx.arc(x + 2, y + 2, radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fill();
                
                // Gradiente
                const gradient = ctx.createRadialGradient(x - 4, y - 4, 0, x, y, radius);
                if (isRainbow) {
                    const hue = (largePreviewAnimFrame * 2 + i * 25) % 360;
                    gradient.addColorStop(0, `hsl(${hue}, 100%, 75%)`);
                    gradient.addColorStop(1, `hsl(${hue}, 100%, 50%)`);
                } else {
                    gradient.addColorStop(0, lightenColorPreview(segColor, 40));
                    gradient.addColorStop(1, segColor);
                }
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Olhos
                if (i === 0) {
                    ctx.beginPath();
                    ctx.arc(x + 5, y - 5, 5, 0, Math.PI * 2);
                    ctx.fillStyle = 'white';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + 6, y - 4, 2.5, 0, Math.PI * 2);
                    ctx.fillStyle = 'black';
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(x + 5, y + 5, 5, 0, Math.PI * 2);
                    ctx.fillStyle = 'white';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + 6, y + 6, 2.5, 0, Math.PI * 2);
                    ctx.fillStyle = 'black';
                    ctx.fill();
                }
            }
            
            largePreviewAnimFrame++;
            if (customizeScreen.classList.contains('active')) {
                requestAnimationFrame(updateLargePreview);
            }
        }

        // Preview mini na tela principal
        function updateMiniPreview() {
            const canvas = document.getElementById('snakePreviewMini');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Verifica se tem skin especial selecionada
            const skinData = SPECIAL_SKINS[selectedSkin];
            let colors, isRainbow, headType;
            
            if (selectedSkin !== 'default' && skinData && skinData.colors) {
                colors = skinData.colors;
                isRainbow = colors[0] === 'rainbow';
                headType = skinData.headType;
            } else {
                colors = playerColorSequence.length > 0 ? playerColorSequence : [playerColor || '#00ff88'];
                isRainbow = colors[0] === 'rainbow';
                headType = null;
            }
            
            const segments = 8;
            
            for (let i = segments - 1; i >= 0; i--) {
                const x = 18 + i * 16;
                const y = 20 + Math.sin((Date.now() * 0.003 + i * 0.5)) * 5;
                const radius = 10 - i * 0.5;
                
                let segColor;
                if (isRainbow) {
                    const hue = (Date.now() * 0.1 + i * 30) % 360;
                    segColor = `hsl(${hue}, 100%, 50%)`;
                } else {
                    segColor = colors[i % colors.length];
                    if (segColor === 'rainbow') {
                        const hue = (Date.now() * 0.1 + i * 30) % 360;
                        segColor = `hsl(${hue}, 100%, 50%)`;
                    }
                }
                
                ctx.beginPath();
                ctx.arc(x + 1, y + 1, radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fill();
                
                const gradient = ctx.createRadialGradient(x - 2, y - 2, 0, x, y, radius);
                if (isRainbow || segColor.startsWith('hsl')) {
                    const hue = (Date.now() * 0.1 + i * 30) % 360;
                    gradient.addColorStop(0, `hsl(${hue}, 100%, 75%)`);
                    gradient.addColorStop(1, segColor.startsWith('hsl') ? segColor : `hsl(${hue}, 100%, 50%)`);
                } else {
                    gradient.addColorStop(0, lightenColorPreview(segColor, 40));
                    gradient.addColorStop(1, segColor);
                }
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
            }
            
            // Desenha cabe√ßa especial ou olhos normais
            const headX = 18;
            const headY = 20 + Math.sin(Date.now() * 0.003) * 5;
            
            if (headType) {
                drawSpecialHead(ctx, headX, headY, 10, 0, headType, colors, Date.now());
            } else {
                ctx.beginPath();
                ctx.arc(headX + 3, headY - 2, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(headX + 3.5, headY - 1.5, 1.5, 0, Math.PI * 2);
                ctx.fillStyle = 'black';
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(headX + 3, headY + 2, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(headX + 3.5, headY + 2.5, 1.5, 0, Math.PI * 2);
                ctx.fillStyle = 'black';
                ctx.fill();
            }
            
            requestAnimationFrame(updateMiniPreview);
        }

        // Event listeners para personaliza√ß√£o
        customizeBtn.addEventListener('click', openCustomizeScreen);
        customizeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); openCustomizeScreen(); });
        
        backFromCustomize.addEventListener('click', closeCustomizeScreen);
        backFromCustomize.addEventListener('touchstart', (e) => { e.preventDefault(); closeCustomizeScreen(); });
        
        clearColorsBtn.addEventListener('click', clearColors);
        clearColorsBtn.addEventListener('touchstart', (e) => { e.preventDefault(); clearColors(); });
        
        saveColorsBtn.addEventListener('click', saveColors);
        saveColorsBtn.addEventListener('touchstart', (e) => { e.preventDefault(); saveColors(); });

        // Criar part√≠culas de fundo animadas
        function createParticles() {
            const particlesBg = document.getElementById('particlesBg');
            if (!particlesBg) return;
            
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 15 + 's';
                particle.style.animationDuration = (10 + Math.random() * 10) + 's';
                
                const colors = ['rgba(0, 255, 136, 0.4)', 'rgba(72, 219, 251, 0.4)', 'rgba(255, 159, 243, 0.4)', 'rgba(254, 202, 87, 0.4)'];
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                particle.style.width = (3 + Math.random() * 4) + 'px';
                particle.style.height = particle.style.width;
                
                particlesBg.appendChild(particle);
            }
        }

        // ==================== SISTEMA DA LOJA ====================
        const shopScreen = document.getElementById('shopScreen');
        const shopBtn = document.getElementById('shopBtn');
        const backFromShop = document.getElementById('backFromShop');
        const skinsGrid = document.getElementById('skinsGrid');

        function openShopScreen() {
            document.getElementById('shopCoins').textContent = playerCoins;
            renderSkins();
            shopScreen.classList.add('active');
        }

        function closeShopScreen() {
            shopScreen.classList.remove('active');
        }

        function renderSkins() {
            skinsGrid.innerHTML = '';
            
            Object.entries(SPECIAL_SKINS).forEach(([skinId, skin]) => {
                const isOwned = unlockedSkins.includes(skinId);
                const isSelected = selectedSkin === skinId;
                const canBuy = playerCoins >= skin.price;
                
                const card = document.createElement('div');
                card.className = 'skin-card' + (isOwned ? ' owned' : ' locked') + (isSelected ? ' selected' : '');
                
                // Preview
                const preview = document.createElement('div');
                preview.className = 'skin-preview';
                const previewCanvas = document.createElement('canvas');
                previewCanvas.width = 180;
                previewCanvas.height = 50;
                preview.appendChild(previewCanvas);
                
                // Desenha preview da skin
                drawSkinPreview(previewCanvas, skin);
                
                // Nome
                const name = document.createElement('div');
                name.className = 'skin-name';
                name.textContent = skin.name;
                
                // Descri√ß√£o
                const desc = document.createElement('div');
                desc.className = 'skin-description';
                desc.textContent = skin.description;
                
                // Pre√ßo ou Status
                const price = document.createElement('div');
                price.className = 'skin-price' + (isOwned ? ' owned' : '');
                if (isOwned) {
                    price.textContent = '‚úì Desbloqueado';
                } else {
                    price.innerHTML = 'ü™ô ' + skin.price;
                }
                
                // Bot√£o
                const btn = document.createElement('button');
                btn.className = 'skin-btn';
                
                if (isOwned) {
                    if (isSelected) {
                        btn.className += ' selected';
                        btn.textContent = '‚úì EQUIPADO';
                        btn.disabled = true;
                    } else {
                        btn.className += ' select';
                        btn.textContent = 'EQUIPAR';
                        btn.onclick = () => selectSkin(skinId);
                    }
                } else {
                    btn.className += ' buy';
                    btn.textContent = 'COMPRAR';
                    btn.disabled = !canBuy;
                    btn.onclick = () => buySkin(skinId, skin.price);
                }
                
                card.appendChild(preview);
                card.appendChild(name);
                card.appendChild(desc);
                card.appendChild(price);
                card.appendChild(btn);
                
                skinsGrid.appendChild(card);
                
                // Anima o preview
                function animatePreview() {
                    if (shopScreen.classList.contains('active')) {
                        drawSkinPreview(previewCanvas, skin);
                        requestAnimationFrame(animatePreview);
                    }
                }
                animatePreview();
            });
        }

        function drawSkinPreview(canvas, skin) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const colors = skin.colors || ['#00ff88'];
            const isRainbow = colors[0] === 'rainbow';
            const headType = skin.headType;
            
            // Desenha corpo
            for (let i = 7; i >= 0; i--) {
                const x = 20 + i * 18;
                const y = 25;
                const radius = 9 - i * 0.3;
                
                let color;
                if (isRainbow) {
                    const hue = (Date.now() * 0.05 + i * 40) % 360;
                    color = `hsl(${hue}, 100%, 50%)`;
                } else {
                    color = colors[i % colors.length];
                }
                
                ctx.beginPath();
                ctx.arc(x + 1, y + 1, radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fill();
                
                const gradient = ctx.createRadialGradient(x - 2, y - 2, 0, x, y, radius);
                if (isRainbow) {
                    const hue = (Date.now() * 0.05 + i * 40) % 360;
                    gradient.addColorStop(0, `hsl(${hue}, 100%, 75%)`);
                    gradient.addColorStop(1, `hsl(${hue}, 100%, 50%)`);
                } else {
                    gradient.addColorStop(0, lightenColorPreview(color, 40));
                    gradient.addColorStop(1, color);
                }
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
            }
            
            // Desenha cabe√ßa especial
            if (headType) {
                drawSpecialHead(ctx, 20, 25, 9, 0, headType, colors, Date.now());
            } else {
                // Olhos normais
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(23, 22, 3, 0, Math.PI * 2);
                ctx.arc(23, 28, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(24, 22, 1.5, 0, Math.PI * 2);
                ctx.arc(24, 28, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function buySkin(skinId, price) {
            if (playerCoins >= price) {
                playerCoins -= price;
                unlockedSkins.push(skinId);
                selectedSkin = skinId;
                
                saveCoins();
                saveUnlockedSkins();
                saveSelectedSkin();
                
                document.getElementById('shopCoins').textContent = playerCoins;
                document.getElementById('displayCoins').textContent = playerCoins;
                
                renderSkins();
            }
        }

        function selectSkin(skinId) {
            selectedSkin = skinId;
            saveSelectedSkin();
            renderSkins();
        }

        // Event listeners da loja
        shopBtn.addEventListener('click', openShopScreen);
        shopBtn.addEventListener('touchstart', (e) => { e.preventDefault(); openShopScreen(); });
        
        backFromShop.addEventListener('click', closeShopScreen);
        backFromShop.addEventListener('touchstart', (e) => { e.preventDefault(); closeShopScreen(); });

        // Inicializa√ß√£o
        function initializeUI() {
            document.getElementById('displayCoins').textContent = playerCoins;
            document.getElementById('displayCrowns').textContent = playerCrowns;
        }

        createParticles();
        updateMiniPreview();
        initializeUI();
    </script>
</body>
</html>
